-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Hydra Plutus Contracts
--   
--   Hydra Plutus Contracts
@package hydra-plutus
@version 0.12.0


-- | Error codes to be used in plutus scripts.
--   
--   Define a new type and instantiate <a>ToErrorCode</a> for error cases
--   you want to use in scripts.
--   
--   <pre>
--   data MyError = CaseA | CaseB deriving Show
--   
--   instance ToErrorCode MyError where
--     toErrorCode = case
--       CaseA -&gt; <a>CA</a>
--       CaseB -&gt; <a>CB</a>
--   </pre>
--   
--   In plutus-tx, you can then use template haskell to inline the error
--   codes using the '$(errorCode ..)' splice.
--   
--   <pre>
--   validator = traceError $(errorCode CaseA)
--   </pre>
--   
--   This example will have your validator fail with user error <a>CA</a>,
--   which you can match for using 'toErrorCode CaseA' in Haskell.
module Hydra.Contract.Error

-- | Types which are used to describe errors as short error codes in
--   scripts.
class ToErrorCode a

-- | Get the short error code used in a script for given type.
toErrorCode :: ToErrorCode a => a -> Text

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp

module Hydra.Contract.CommitError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data CommitError
STNotBurnedError :: CommitError
STIsMissingInTheOutput :: CommitError
instance GHC.Show.Show Hydra.Contract.CommitError.CommitError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.CommitError.CommitError

module Hydra.Contract.HeadError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadError
InvalidHeadStateTransition :: HeadError
BurntTokenNumberMismatch :: HeadError
ReimbursedOutputsDontMatch :: HeadError
STNotSpent :: HeadError
IncorrectUtxoHash :: HeadError
ChangedParameters :: HeadError
WrongStateInOutputDatum :: HeadError
MissingCommits :: HeadError
HeadValueIsNotPreserved :: HeadError
HasBoundedValidityCheckFailed :: HeadError
InvalidSnapshotSignature :: HeadError
ClosedWithNonInitialHash :: HeadError
IncorrectClosedContestationDeadline :: HeadError
InfiniteUpperBound :: HeadError
InfiniteLowerBound :: HeadError
ContestersNonEmpty :: HeadError
TooOldSnapshot :: HeadError
UpperBoundBeyondContestationDeadline :: HeadError
ContestNoUpperBoundDefined :: HeadError
MustNotPushDeadline :: HeadError
MustPushDeadline :: HeadError
ContesterNotIncluded :: HeadError
WrongNumberOfSigners :: HeadError
SignerAlreadyContested :: HeadError
FannedOutUtxoHashNotEqualToClosedUtxoHash :: HeadError
LowerBoundBeforeContestationDeadline :: HeadError
FanoutNoLowerBoundDefined :: HeadError
CloseNoUpperBoundDefined :: HeadError
ScriptNotSpendingAHeadInput :: HeadError
SignerIsNotAParticipant :: HeadError
NoSigners :: HeadError
TooManySigners :: HeadError
NoOutputDatumError :: HeadError
DatumNotFound :: HeadError
SignatureVerificationFailed :: HeadError
PartySignatureVerificationFailed :: HeadError
NotPayingToHead :: HeadError
NotAllValueCollected :: HeadError
instance GHC.Show.Show Hydra.Contract.HeadError.HeadError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadError.HeadError

module Hydra.Contract.HeadTokensError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data HeadTokensError
SeedNotSpent :: HeadTokensError
WrongNumberOfTokensMinted :: HeadTokensError
MissingST :: HeadTokensError
WrongNumberOfInitialOutputs :: HeadTokensError
WrongDatum :: HeadTokensError
MintingNotAllowed :: HeadTokensError
NoPT :: HeadTokensError
WrongQuantity :: HeadTokensError
HeadDatum :: HeadTokensError
NoDatum :: HeadTokensError
MultipleHeadOutput :: HeadTokensError
instance GHC.Show.Show Hydra.Contract.HeadTokensError.HeadTokensError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.HeadTokensError.HeadTokensError

module Hydra.Contract.InitialError

-- | Get the string literal from given error <tt>e</tt>. Use this with
--   template haskell splices, e.g. $(errorCode MyError)
errorCode :: ToErrorCode e => e -> Q Exp
data InitialError
STNotBurned :: InitialError
MissingOrInvalidCommitAuthor :: InitialError
LockedValueDoesNotMatch :: InitialError
MismatchCommittedTxOutInDatum :: InitialError
CouldNotFindTheCorrectCurrencySymbolInTokens :: InitialError
MultipleHeadTokensOrMoreThan1PTsFound :: InitialError
MissingCommittedTxOutInOutputDatum :: InitialError
CommittedTxOutMissingInOutputDatum :: InitialError
MissingDatum :: InitialError
UnexpectedInlineDatum :: InitialError
CouldNotFindDatum :: InitialError
ExpectedCommitDatumTypeGotSomethingElse :: InitialError
ExpectedSingleCommitOutput :: InitialError
WrongHeadIdInCommitDatum :: InitialError
MintingOrBurningIsForbidden :: InitialError
OutRefNotFound :: InitialError
instance GHC.Show.Show Hydra.Contract.InitialError.InitialError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.InitialError.InitialError


-- | Data type used in <a>HeadTokens</a> as a separate module because of
--   TemplateHaskell stage restriction.
module Hydra.Contract.MintAction
data MintAction
Mint :: MintAction
Burn :: MintAction
instance PlutusTx.IsData.Class.ToData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.FromData Hydra.Contract.MintAction.MintAction
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.MintAction.MintAction

module Hydra.Contract.Util
hydraHeadV1 :: BuiltinByteString

-- | Checks that the output contains the state token (ST) with the head
--   <a>CurrencySymbol</a> and <a>TokenName</a> of <a>hydraHeadV1</a>
hasST :: CurrencySymbol -> Value -> Bool

-- | Checks if all the state token (ST) for list of parties containing
--   specific <a>CurrencySymbol</a> are burnt.
mustBurnST :: Value -> CurrencySymbol -> Bool
mustNotMintOrBurn :: TxInfo -> Bool

-- | Checks for exact exuality between two serialized values Equality on
--   value is very memory intensive as it's defined on associative lists
--   and Map equality is implemented. Instead we can be more strict and
--   require EXACTLY the same value and compare using the serialised bytes.
(===) :: Value -> Value -> Bool
infix 4 ===
data UtilError
MintingOrBurningIsForbidden :: UtilError
instance GHC.Show.Show Hydra.Contract.Util.UtilError
instance Hydra.Contract.Error.ToErrorCode Hydra.Contract.Util.UtilError

module Hydra.Data.ContestationPeriod
newtype ContestationPeriod
UnsafeContestationPeriod :: DiffMilliSeconds -> ContestationPeriod
[milliseconds] :: ContestationPeriod -> DiffMilliSeconds
contestationPeriodFromDiffTime :: NominalDiffTime -> ContestationPeriod
contestationPeriodToDiffTime :: ContestationPeriod -> NominalDiffTime

-- | Compute the (on-chain) contestation deadline from a given current time
--   and the <a>ContestationPeriod</a>.
addContestationPeriod :: POSIXTime -> ContestationPeriod -> POSIXTime

-- | Convert given on-chain <a>POSIXTime</a> to a <a>UTCTime</a>.
posixToUTCTime :: POSIXTime -> UTCTime

-- | Compute on-chain <a>POSIXTime</a> from a given <a>UTCTime</a>.
posixFromUTCTime :: UTCTime -> POSIXTime
instance PlutusTx.IsData.Class.ToData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.FromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.ContestationPeriod.ContestationPeriod
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Data.ContestationPeriod.ContestationPeriod
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Data.ContestationPeriod.ContestationPeriod
instance PlutusTx.Eq.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Num.Num Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Show.Show Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Ord Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Classes.Eq Hydra.Data.ContestationPeriod.ContestationPeriod
instance GHC.Generics.Generic Hydra.Data.ContestationPeriod.ContestationPeriod

module Hydra.Data.Party

-- | On-chain representation of a Hydra party.
--   
--   NOTE: This roughly corresponds to the <a>Party</a> in 'hydra-node',
--   but is simplified to allow usage of this type in plutus-tx. If we
--   would use the complex type directly, which is based on
--   'cardano-crypto-class', we would get errors like "Error: Unsupported
--   feature: Kind: GHC.Types.Nat".
--   
--   The data constructor should not be used to construct this value as it
--   would always come from off-chain code via
--   <a>partyFromVerificationKeyBytes</a>.
newtype Party
UnsafeParty :: BuiltinByteString -> Party
[vkey] :: Party -> BuiltinByteString

-- | Create an on-chain <a>Party</a> from some verification key bytes.
partyFromVerificationKeyBytes :: ByteString -> Party

-- | Get the verification key bytes contained from an on-chain
--   <a>Party</a>.
partyToVerficationKeyBytes :: Party -> ByteString
instance PlutusTx.Eq.Eq Hydra.Data.Party.Party
instance GHC.Show.Show Hydra.Data.Party.Party
instance GHC.Generics.Generic Hydra.Data.Party.Party
instance GHC.Classes.Eq Hydra.Data.Party.Party
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.ToData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.FromData Hydra.Data.Party.Party
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.Party.Party
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Data.Party.Party
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Data.Party.Party

module Hydra.Contract.HeadState
type SnapshotNumber = Integer
type Hash = BuiltinByteString
type Signature = BuiltinByteString
data State
Initial :: ContestationPeriod -> [Party] -> CurrencySymbol -> TxOutRef -> State
[$sel:contestationPeriod:Initial] :: State -> ContestationPeriod
[$sel:parties:Initial] :: State -> [Party]
[$sel:headId:Initial] :: State -> CurrencySymbol
[$sel:seed:Initial] :: State -> TxOutRef
Open :: ContestationPeriod -> [Party] -> Hash -> CurrencySymbol -> State
[$sel:contestationPeriod:Initial] :: State -> ContestationPeriod
[$sel:parties:Initial] :: State -> [Party]
[$sel:utxoHash:Initial] :: State -> Hash
[$sel:headId:Initial] :: State -> CurrencySymbol
Closed :: [Party] -> SnapshotNumber -> Hash -> POSIXTime -> ContestationPeriod -> CurrencySymbol -> [PubKeyHash] -> State
[$sel:parties:Initial] :: State -> [Party]
[$sel:snapshotNumber:Initial] :: State -> SnapshotNumber
[$sel:utxoHash:Initial] :: State -> Hash
[$sel:contestationDeadline:Initial] :: State -> POSIXTime
[$sel:contestationPeriod:Initial] :: State -> ContestationPeriod
[$sel:headId:Initial] :: State -> CurrencySymbol
[$sel:contesters:Initial] :: State -> [PubKeyHash]
Final :: State
data Input
CollectCom :: Input
Close :: [Signature] -> Input
[$sel:signature:CollectCom] :: Input -> [Signature]
Contest :: [Signature] -> Input
[$sel:signature:CollectCom] :: Input -> [Signature]
Abort :: Input
Fanout :: Integer -> Input
[$sel:numberOfFanoutOutputs:CollectCom] :: Input -> Integer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.Input
instance GHC.Show.Show Hydra.Contract.HeadState.Input
instance GHC.Generics.Generic Hydra.Contract.HeadState.Input
instance PlutusTx.IsData.Class.ToData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.FromData Hydra.Contract.HeadState.State
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.HeadState.State
instance GHC.Show.Show Hydra.Contract.HeadState.State
instance GHC.Generics.Generic Hydra.Contract.HeadState.State


-- | Module for the on-chain representation of Utxo.
module Hydra.Data.Utxo
newtype Utxo
Utxo :: BuiltinByteString -> Utxo
fromByteString :: ByteString -> Utxo
toByteString :: Utxo -> ByteString
instance PlutusTx.IsData.Class.FromData Hydra.Data.Utxo.Utxo
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Data.Utxo.Utxo
instance PlutusTx.IsData.Class.ToData Hydra.Data.Utxo.Utxo


-- | A custom ScriptContext and TxInfo which only "decodes" the fields we
--   need.
module Hydra.ScriptContext
data TxInfo
TxInfo :: [TxInInfo] -> BuiltinData -> [TxOut] -> Value -> Value -> BuiltinData -> BuiltinData -> BuiltinData -> [PubKeyHash] -> BuiltinData -> Map DatumHash Datum -> BuiltinData -> TxInfo

-- | Transaction inputs; cannot be an empty list
[txInfoInputs] :: TxInfo -> [TxInInfo]

-- | Transaction reference inputs
[txInfoReferenceInputs] :: TxInfo -> BuiltinData

-- | Transaction outputs
[txInfoOutputs] :: TxInfo -> [TxOut]

-- | The fee paid by this transaction.
[txInfoFee] :: TxInfo -> Value

-- | The <a>Value</a> minted by this transaction.
[txInfoMint] :: TxInfo -> Value

-- | Digests of certificates included in this transaction
[txInfoDCert] :: TxInfo -> BuiltinData

-- | Withdrawals
[txInfoWdrl] :: TxInfo -> BuiltinData

-- | The valid range for the transaction.
[txInfoValidRange] :: TxInfo -> BuiltinData

-- | Signatures provided with the transaction, attested that they all
--   signed the tx
[txInfoSignatories] :: TxInfo -> [PubKeyHash]

-- | A table of redeemers attached to the transaction
[txInfoRedeemers] :: TxInfo -> BuiltinData

-- | The lookup table of datums attached to the transaction
[txInfoData] :: TxInfo -> Map DatumHash Datum

-- | Hash of the pending transaction body (i.e. transaction excluding
--   witnesses)
[txInfoId] :: TxInfo -> BuiltinData

-- | The context that the currently-executing script can access.
data ScriptContext
ScriptContext :: TxInfo -> ScriptPurpose -> ScriptContext

-- | information about the transaction the currently-executing script is
--   included in
[scriptContextTxInfo] :: ScriptContext -> TxInfo

-- | the purpose of the currently-executing script
[scriptContextPurpose] :: ScriptContext -> ScriptPurpose

-- | Get the list of <a>TxOut</a> outputs of the pending transaction at a
--   given script address.
scriptOutputsAt :: ScriptHash -> TxInfo -> [(OutputDatum, Value)]

-- | Get the total value locked by the given validator in this transaction.
valueLockedBy :: TxInfo -> ScriptHash -> Value

-- | Find the input currently being validated.
findOwnInput :: ScriptContext -> Maybe TxInInfo

-- | Find the data corresponding to a data hash, if there is one
findDatum :: DatumHash -> TxInfo -> Maybe Datum

-- | Given a UTXO reference and a transaction (<a>TxInfo</a>), resolve it
--   to one of the transaction's inputs (<a>TxInInfo</a>).
findTxInByTxOutRef :: TxOutRef -> TxInfo -> Maybe TxInInfo

-- | The <a>CurrencySymbol</a> of the current validator script.
ownCurrencySymbol :: ScriptContext -> CurrencySymbol
instance PlutusTx.IsData.Class.ToData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.FromData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.ScriptContext.ScriptContext
instance PlutusTx.IsData.Class.ToData Hydra.ScriptContext.TxInfo
instance PlutusTx.IsData.Class.FromData Hydra.ScriptContext.TxInfo
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.ScriptContext.TxInfo

module Plutus.Extras

-- | Signature of an untyped validator script.
type ValidatorType = BuiltinData -> BuiltinData -> BuiltinData -> ()

-- | Wrap a typed validator to get the basic <a>ValidatorType</a> signature
--   which can be passed to <a>compile</a>. REVIEW: There might be better
--   ways to name this than "wrap"
wrapValidator :: (UnsafeFromData datum, UnsafeFromData redeemer, UnsafeFromData context) => (datum -> redeemer -> context -> Bool) -> ValidatorType

-- | Signature of an untyped minting policy script.
type MintingPolicyType = BuiltinData -> BuiltinData -> ()

-- | Wrap a typed minting policy to get the basic <a>MintingPolicyType</a>
--   signature which can be passed to <a>compile</a>.
wrapMintingPolicy :: (UnsafeFromData redeemer, UnsafeFromData context) => (redeemer -> context -> Bool) -> MintingPolicyType

-- | Compute the on-chain <a>ScriptHash</a> for a given serialised plutus
--   script. Use this to refer to another validator script.
scriptValidatorHash :: SerialisedScript -> ScriptHash


-- | An experimental validator which simply hashes a bytestring stored in
--   the datum using one of three supported algorithms.
module Hydra.Contract.Hash
data HashAlgorithm
Base :: HashAlgorithm
SHA2 :: HashAlgorithm
SHA3 :: HashAlgorithm
Blake2b :: HashAlgorithm
type DatumType = BuiltinByteString
type RedeemerType = HashAlgorithm
validator :: DatumType -> RedeemerType -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Hash.HashAlgorithm
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Hash.HashAlgorithm
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Hash.HashAlgorithm
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Contract.Hash.HashAlgorithm
instance GHC.Enum.Bounded Hydra.Contract.Hash.HashAlgorithm
instance GHC.Enum.Enum Hydra.Contract.Hash.HashAlgorithm
instance GHC.Generics.Generic Hydra.Contract.Hash.HashAlgorithm
instance GHC.Show.Show Hydra.Contract.Hash.HashAlgorithm


-- | The validator used to collect &amp; open or abort a Head.
module Hydra.Contract.Commit
data CommitRedeemer
ViaCollectCom :: CommitRedeemer
ViaAbort :: CommitRedeemer

-- | A data type representing comitted outputs on-chain. Besides recording
--   the original <a>TxOutRef</a>, it also stores a binary representation
--   compatible between on- and off-chain code to be hashed in the
--   validators.
data Commit
Commit :: TxOutRef -> BuiltinByteString -> Commit
[input] :: Commit -> TxOutRef
[preSerializedOutput] :: Commit -> BuiltinByteString

-- | Record an off-chain <tt>TxOut</tt> as a <a>Commit</a> on-chain. NOTE:
--   Depends on the <tt>Serialise</tt> instance for Plutus' <tt>Data</tt>.
serializeCommit :: (TxIn, TxOut CtxUTxO) -> Maybe Commit

-- | Decode an on-chain <tt>SerializedTxOut</tt> back into an off-chain
--   <tt>TxOut</tt>. NOTE: Depends on the <tt>Serialise</tt> instance for
--   Plutus' <tt>Data</tt>.
deserializeCommit :: Network -> Commit -> Maybe (TxIn, TxOut CtxUTxO)
type DatumType = (Party, [Commit], CurrencySymbol)
type RedeemerType = CommitRedeemer

-- | The v_commit validator verifies that:
--   
--   <ul>
--   <li>spent in a transaction also consuming a v_head output</li>
--   <li>ST is burned if the redeemer is <a>ViaAbort</a></li>
--   <li>ST is present in the output if the redeemer is
--   <a>ViaCollectCom</a></li>
--   </ul>
validator :: DatumType -> RedeemerType -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.Commit
instance GHC.Classes.Ord Hydra.Contract.Commit.Commit
instance GHC.Show.Show Hydra.Contract.Commit.Commit
instance GHC.Classes.Eq Hydra.Contract.Commit.Commit
instance PlutusTx.Eq.Eq Hydra.Contract.Commit.Commit
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Commit.CommitRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Commit.CommitRedeemer


-- | The initial validator which allows participants to commit or abort.
module Hydra.Contract.Initial
data InitialRedeemer
ViaAbort :: InitialRedeemer
ViaCommit :: [TxOutRef] -> InitialRedeemer

-- | Points to the committed Utxo.
[committedRefs] :: InitialRedeemer -> [TxOutRef]
type DatumType = CurrencySymbol
type RedeemerType = InitialRedeemer

-- | The v_initial validator verifies that:
--   
--   <ul>
--   <li>spent in a transaction also consuming a v_head output</li>
--   <li>ensures the committed value is recorded correctly in the output
--   datum</li>
--   <li>ensures that the transaction was signed by the key corresponding
--   to the PubKeyHash encoded in the participation token name</li>
--   </ul>
--   
--   NOTE: It does not need to ensure that the participation token is of
--   some specific Head currency.
validator :: ScriptHash -> DatumType -> RedeemerType -> ScriptContext -> Bool
checkCommit :: ScriptHash -> CurrencySymbol -> [TxOutRef] -> ScriptContext -> Bool
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash
datum :: DatumType -> Datum
redeemer :: RedeemerType -> Redeemer
instance PlutusTx.IsData.Class.ToData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.FromData Hydra.Contract.Initial.InitialRedeemer
instance PlutusTx.IsData.Class.UnsafeFromData Hydra.Contract.Initial.InitialRedeemer

module Hydra.Contract.Head
type DatumType = State
type RedeemerType = Input
headValidator :: State -> Input -> ScriptContext -> Bool

-- | On-Chain verification for <a>Abort</a> transition. It verifies that:
--   
--   <ul>
--   <li>All PTs have been burnt: The right number of Head tokens with the
--   correct head id are burnt, one PT for each party and a state token
--   ST.</li>
--   <li>All committed funds have been redistributed. This is done via
--   v_commit and it only needs to ensure that we have spent all comitted
--   outputs, which follows from burning all the PTs.</li>
--   </ul>
checkAbort :: ScriptContext -> CurrencySymbol -> [Party] -> Bool

-- | On-Chain verification for <a>CollectCom</a> transition. It verifies
--   that:
--   
--   <ul>
--   <li>All participants have committed (even empty commits)</li>
--   <li>All commits are properly collected and locked into η as a hash of
--   serialized tx outputs in the same sequence as commit inputs!</li>
--   <li>The transaction is performed (i.e. signed) by one of the head
--   participants</li>
--   <li>State token (ST) is present in the output</li>
--   </ul>
checkCollectCom :: ScriptContext -> (ContestationPeriod, [Party], CurrencySymbol) -> Bool

-- | Try to find the commit datum in the input and if it is there return
--   the committed utxo
commitDatum :: TxInfo -> TxOut -> [Commit]

-- | The close validator must verify that:
--   
--   <ul>
--   <li>Check that the closing tx validity is bounded by contestation
--   period</li>
--   <li>Check that the deadline corresponds with tx validity and
--   contestation period.</li>
--   <li>The resulting utxo hash is correctly signed or the initial utxo
--   hash, depending on snapshot number</li>
--   <li>The transaction is performed (i.e. signed) by one of the head
--   participants</li>
--   <li>State token (ST) is present in the output</li>
--   <li>Contesters must be initialize as empty</li>
--   <li>Value in v_head is preserved</li>
--   </ul>
checkClose :: ScriptContext -> [Party] -> BuiltinByteString -> [Signature] -> ContestationPeriod -> CurrencySymbol -> Bool

-- | The contest validator must verify that:
--   
--   <ul>
--   <li>The transaction does not mint or burn tokens.</li>
--   <li>The contest snapshot number is strictly greater than the closed
--   snapshot number.</li>
--   <li>The contest snapshot is correctly signed.</li>
--   <li>The transaction is performed (i.e. signed) by one of the head
--   participants</li>
--   <li>Party can contest only once.</li>
--   <li>The transaction is performed before the deadline.</li>
--   <li>Add signer to list of contesters.</li>
--   <li>State token (ST) is present in the output</li>
--   <li>Push deadline if signer is not the last one to contest.</li>
--   <li>No other parameters have changed.</li>
--   <li>Value in v_head is preserved</li>
--   </ul>
checkContest :: ScriptContext -> POSIXTime -> ContestationPeriod -> [Party] -> SnapshotNumber -> [Signature] -> [PubKeyHash] -> CurrencySymbol -> Bool
checkFanout :: BuiltinByteString -> POSIXTime -> Integer -> ScriptContext -> Bool
(&) :: a -> (a -> b) -> b
txOutAdaValue :: TxOut -> Integer
txInfoAdaFee :: TxInfo -> Integer
makeContestationDeadline :: ContestationPeriod -> ScriptContext -> POSIXTime
getHeadAddress :: ScriptContext -> Address
mustBeSignedByParticipant :: ScriptContext -> CurrencySymbol -> Bool
findParticipationTokens :: CurrencySymbol -> Value -> [TokenName]
headOutputDatum :: ScriptContext -> Datum
findTxOutDatum :: TxInfo -> TxOut -> Datum

-- | Hash a potentially unordered list of commits by sorting them,
--   concatenating their <a>preSerializedOutput</a> bytes and creating a
--   SHA2_256 digest over that.
hashPreSerializedCommits :: [Commit] -> BuiltinByteString

-- | Hash a pre-ordered list of transaction outputs by serializing each
--   individual <a>TxOut</a>, concatenating all bytes together and creating
--   a SHA2_256 digest over that.
hashTxOuts :: [TxOut] -> BuiltinByteString

-- | Check if <a>TxOut</a> contains the PT token.
hasPT :: CurrencySymbol -> TxOut -> Bool
verifySnapshotSignature :: [Party] -> SnapshotNumber -> BuiltinByteString -> [Signature] -> Bool
verifyPartySignature :: SnapshotNumber -> BuiltinByteString -> Party -> Signature -> Bool
compareRef :: TxOutRef -> TxOutRef -> Ordering
compiledValidator :: CompiledCode ValidatorType
validatorScript :: SerialisedScript
validatorHash :: ScriptHash


-- | Minting policy for a single head tokens.
module Hydra.Contract.HeadTokens
validate :: ScriptHash -> ScriptHash -> TxOutRef -> MintAction -> ScriptContext -> Bool

-- | When minting head tokens we want to make sure that:
--   
--   <ul>
--   <li>The number of minted PTs == number of participants (+1 for the ST)
--   evident from the datum.</li>
--   <li>There is single state token that is paid into v_head, which
--   ensures continuity.</li>
--   <li>PTs are distributed to v_initial.</li>
--   <li>Ensure out-ref and the headId are in the datum of the first output
--   of the transaction which mints tokens.</li>
--   </ul>
validateTokensMinting :: ScriptHash -> ScriptHash -> TxOutRef -> ScriptContext -> Bool

-- | Token burning check should: * Not restrict burning on the mu_head at
--   all.
--   
--   It is ensured by the v_head validator, when tokens of a specific
--   headId may be burned.
--   
--   <a>validateTokensBurning</a> just makes sure all tokens have negative
--   quantity.
validateTokensBurning :: ScriptContext -> Bool

-- | Raw minting policy code where the <a>TxOutRef</a> is still a
--   parameter.
unappliedMintingPolicy :: CompiledCode (TxOutRef -> MintingPolicyType)

-- | Get the applied head minting policy script given a seed
--   <a>TxOutRef</a>.
mintingPolicyScript :: TxOutRef -> SerialisedScript

-- | Get the head policy id (a.k.a headId) given a seed <a>TxIn</a>.
headPolicyId :: TxIn -> PolicyId

-- | Get the applied head minting policy script given a seed <a>TxIn</a>.
mkHeadTokenScript :: TxIn -> PlutusScript


-- | Things related to the Hydra smart contracts / script validators.
module Hydra.Contract

-- | Information about relevant Hydra scripts.
data ScriptInfo
ScriptInfo :: ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptHash -> Int64 -> ScriptInfo

-- | Hash of the μHead minting script given some default parameters.
[mintingScriptHash] :: ScriptInfo -> ScriptHash

-- | Size of the μHead minting script given some default parameters.
[mintingScriptSize] :: ScriptInfo -> Int64
[initialScriptHash] :: ScriptInfo -> ScriptHash
[initialScriptSize] :: ScriptInfo -> Int64
[commitScriptHash] :: ScriptInfo -> ScriptHash
[commitScriptSize] :: ScriptInfo -> Int64
[headScriptHash] :: ScriptInfo -> ScriptHash
[headScriptSize] :: ScriptInfo -> Int64

-- | Gather <a>ScriptInfo</a> from the current Hydra scripts. This is
--   useful to determine changes in between version of 'hydra-plutus'.
scriptInfo :: ScriptInfo
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Contract.ScriptInfo
instance GHC.Generics.Generic Hydra.Contract.ScriptInfo
instance GHC.Show.Show Hydra.Contract.ScriptInfo
instance GHC.Classes.Eq Hydra.Contract.ScriptInfo


-- | Orphans instances partly copied from Plutus, partly coming from us for
--   test purpose.
module Plutus.Orphans
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusTx.Builtins.Internal.BuiltinByteString
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.TokenName
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.CurrencySymbol
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Value.Value
instance (Test.QuickCheck.Arbitrary.Arbitrary k, Test.QuickCheck.Arbitrary.Arbitrary v) => Test.QuickCheck.Arbitrary.Arbitrary (PlutusTx.AssocMap.Map k v)
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Time.POSIXTime
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Time.POSIXTime
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Time.POSIXTime
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (PlutusLedgerApi.V1.Interval.UpperBound a)
instance Data.Aeson.Types.ToJSON.ToJSON PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Data.Aeson.Types.FromJSON.FromJSON PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Crypto.PubKeyHash
instance Test.QuickCheck.Arbitrary.Arbitrary PlutusLedgerApi.V1.Tx.TxOutRef
