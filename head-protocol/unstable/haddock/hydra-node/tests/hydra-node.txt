-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Hydra node
@package hydra-node
@version 0.11.0

module Hydra.API.ClientInputSpec
spec :: Spec
settings :: Settings

module Hydra.API.ServerOutputSpec
spec :: Spec
settings :: Settings


-- | Generators used in mutation testing framework
module Hydra.Chain.Direct.Contract.Gen

-- | Generate some <tt>a</tt> given the Party as a seed. NOTE: While this
--   is useful to generate party-specific values, it DOES depend on the
--   generator used. For example, `genForParty genVerificationKey` and
--   `genForParty (fst <a>$</a> genKeyPair)` do not yield the same
--   verification keys!
genForParty :: Gen a -> Party -> a
genBytes :: Gen ByteString
genHash :: Gen ByteString

-- | Generates value such that: - alters between policy id we use in test
--   fixtures with a random one. - mixing arbitrary token names with
--   <a>hydraHeadV1</a> - excluding 0 for quantity to mimic minting/burning
genMintedOrBurnedValue :: Gen Value


-- | Provides building blocks for Mutation testing of Contracts.
--   
--   <h2>Introduction</h2>
--   
--   Traditional <a>Mutation testing</a> is a testing technique that
--   introduces small modifications like changing a comparison operator, or
--   modifying constants, into a program and checks whether or not the
--   existing tests "kill" the produced mutants, eg. fail. Mutation testing
--   requires somewhat complex tooling because it needs to modify the
--   source code, in limited and semantically meaningful ways in order to
--   generate code that won't be rejected by the compiler.
--   
--   Recall that Plutus eUTxO validators are boolean expressions of the
--   form:
--   
--   <pre>
--   validator : Datum -&gt; Redeemer -&gt; ScriptContext -&gt; Bool
--   </pre>
--   
--   All things being equal, "mutating" a <i>validator</i> so that it
--   returns <a>False</a> instead of <a>True</a> can be done:
--   
--   <ul>
--   <li>Either by <i>mutating</i> the code of the <tt>validator</tt>
--   implementation,</li>
--   <li>Or by <i>mutating</i> its arguments.</li>
--   </ul>
--   
--   This simple idea lead to the following strategy to test-drive
--   validator scripts:
--   
--   <ol>
--   <li>Start with a validator that always return <a>True</a>,</li>
--   <li>Write a <i>positive</i> property test checking <i>valid</i>
--   transactions are accepted by the validator(s),</li>
--   <li>Write a <i>negative</i> property test checking <i>invalid</i>
--   transactions are rejected. This is where <i>mutations</i> are
--   introduced, each different mutation type representing some possible
--   "attack",</li>
--   <li>Watch one or the other properties fail and enhance the validators
--   code to make them pass,</li>
--   <li>Rinse and repeat.</li>
--   </ol>
--   
--   <h2>Generic Property and Mutations</h2>
--   
--   Given a transaction with some UTxO context, and a function that
--   generates <a>SomeMutation</a> from a valid transaction and context
--   pair, the generic <a>propMutation</a> property checks applying any
--   generated mutation makes the mutated (hence expectedly invalid)
--   transaction fail the validation stage.
--   
--   <pre>
--   propMutation :: (Tx, Utxo) -&gt; ((Tx, Utxo) -&gt; Gen SomeMutation) -&gt; Property
--   propMutation (tx, utxo) genMutation =
--     forAll <tt>_ </tt>Property (genMutation (tx, utxo)) $ SomeMutation{label, mutation} -&gt;
--       (tx, utxo)
--         &amp; applyMutation mutation
--         &amp; propTransactionFailsPhase2
--   </pre>
--   
--   To this basic property definition we add a <a>checkCoverage</a> that
--   ensures the set of generated mutations covers a statistically
--   significant share of each of the various possible mutations classified
--   by their <tt>label</tt>.
--   
--   The <a>SomeMutation</a> type is simply a wrapper that attaches a
--   <tt>label</tt> to a proper <a>Mutation</a> which is the interesting
--   bit here.
--   
--   The <a>Mutation</a> type enumerates various possible "atomic"
--   mutations which preserve the structural correctness of the transaction
--   but should make a validator fail.
--   
--   <pre>
--   data Mutation
--     = ChangeHeadRedeemer Head.Input
--     | ChangeInputHeadDatum Head.State
--     ...
--     | Changes [Mutation]
--   </pre>
--   
--   The constructors should hopefully be self-explaining but for the last
--   one. Some interesting mutations we want to make require more than one
--   "atomic" change to represent a possible validator failure. For
--   example, we wanted to check that the <tt>Commit</tt> validator, in the
--   context of a <tt>CollectCom</tt> transaction, verifies the state
--   (<tt>Input</tt>) of the <tt>Head</tt> validator is correct. But to be
--   interesting, this mutation needs to ensure the <i>transition</i>
--   verified by the <tt>Head</tt> state machine is valid, which requires
--   changing <i>both</i> the datum and the redeemer of the consumed head
--   output.
--   
--   <h2>Transaction-specific Mutations</h2>
--   
--   To be run the <a>propMutation</a> requires a starting "healthy"
--   (valid) transaction and a specialised generating function. It is
--   instantiated in the test runner by providing these two elements. For
--   example, the <a>ContractSpec</a> module has the following property
--   check:
--   
--   <pre>
--   describe <a>CollectCom</a> $ do
--     prop "does not survive random adversarial mutations" $
--       propMutation healthyCollectComTx genCollectComMutation
--   </pre>
--   
--   The interesting part is the <tt>genCollectComMutation</tt> (details of
--   the <a>Mutation</a> generators are omitted):
--   
--   <pre>
--   genCollectComMutation :: (Tx, Utxo) -&gt; Gen SomeMutation
--   genCollectComMutation (tx, utxo) =
--     oneof
--       [ SomeMutation Nothing MutateOpenOutputValue . ChangeOutput ...
--       , SomeMutation Nothing MutateOpenUtxoHash . ChangeOutput ...
--       , SomeMutation Nothing MutateHeadTransition <a>$</a> do
--           changeRedeemer <a>ChangeHeadRedeemer &lt;$</a> ...
--           changeDatum <a>ChangeInputHeadDatum &lt;$</a> ...
--           pure $ Changes [changeRedeemer, changeDatum]
--       ]
--   </pre>
--   
--   Here we have defined four different type of mutations that are
--   interesting for the <a>CollectCom</a> transaction and represent
--   possible <i>attack vectors</i>:
--   
--   <ul>
--   <li>Changing the <tt>Head</tt> output's value, which would imply some
--   of the committed funds could be "stolen" by the party posting the
--   transaction,</li>
--   <li>Tampering with the content of the UTxO committed to the Head,</li>
--   <li>Trying to collect commits without running the <tt>Head</tt>
--   validator,</li>
--   <li>Trying to collect commits in another Head state machine
--   transition.</li>
--   </ul>
--   
--   <h2>Running Properties</h2>
--   
--   When such a property test succeeds we get the following report which
--   shows the distribution of the various mutations that were tested.
--   
--   <pre>
--   Hydra.Chain.Direct.Contract
--     CollectCom
--       does not survive random adversarial mutations
--         +++ OK, passed 200 tests.
--   
--         CollectComMutation (100 in total):
--         23% MutateNumberOfParties
--         22% MutateHeadTransition
--         21% MutateHeadId
--         19% MutateOpenUTxOHash
--         15% MutateRequiredSigner
--   
--   Finished in 18.1146 seconds
--   </pre>
--   
--   In the case of a failure we get a detailed report on the context of
--   the failure.
module Hydra.Chain.Direct.Contract.Mutation

-- | A <a>Property</a> checking a mutation is not validated. This property
--   takes an initial (transaction, UTxO) pair that is supposedly valid,
--   passes it to a generator that produces some mutations, then assert the
--   resulting (transaction', UTxO') pair fails the validation process.
--   
--   Note that only "level 2" validation is run, e.g the transaction is
--   assume to be structurally valid and having passed "level 1" checks.
propMutation :: (Tx, UTxO) -> ((Tx, UTxO) -> Gen SomeMutation) -> Property

-- | Expect a phase-2 evaluation failure of given <a>Tx</a> and
--   <a>UTxO'</a>.
propTransactionFailsPhase2 :: Maybe Text -> (Tx, UTxO) -> Property

-- | Expect a given <a>Tx</a> and <a>UTxO'</a> to pass evaluation.
propTransactionEvaluates :: (Tx, UTxO) -> Property

-- | Expect a given <a>Tx</a> and <a>UTxO'</a> to fail phase 1 or phase 2
--   evaluation.
propTransactionFailsEvaluation :: (Tx, UTxO) -> Property

-- | Existential wrapper <a>SomeMutation</a> and some label type. This type
--   is useful to provide a "generic" classification of mutation that is
--   controlled by some custom type. The <a>$sel:label:SomeMutation</a>
--   field can be passed to the <a>genericCoverTable</a> function to
--   construct and display a coverage table showing the percentage of each
--   mutation that's been applied and ensure significant coverage of all
--   possible mutations using <a>checkCoverage</a>.
data SomeMutation
SomeMutation :: Maybe Text -> lbl -> Mutation -> SomeMutation
[$sel:expectedError:SomeMutation] :: SomeMutation -> Maybe Text
[$sel:label:SomeMutation] :: SomeMutation -> lbl
[$sel:mutation:SomeMutation] :: SomeMutation -> Mutation

-- | Basic mutations
data Mutation

-- | Changes the <tt>Head</tt> script's redeemer to the given value.
ChangeHeadRedeemer :: Input -> Mutation

-- | Changes the spent <tt>Head</tt> script datum to the given value. This
--   modifies both the <tt>DatumHash</tt> in the UTxO context and the map
--   of <tt>DatumHash</tt> to <tt>Datum</tt> in the transaction's
--   witnesses.
ChangeInputHeadDatum :: State -> Mutation

-- | Adds given output as first transaction output.
PrependOutput :: TxOut CtxTx -> Mutation

-- | Adds given output as last transaction output.
AppendOutput :: TxOut CtxTx -> Mutation

-- | Removes given output from the transaction's outputs.
RemoveOutput :: Word -> Mutation

-- | Drops the given input from the transaction's inputs
RemoveInput :: TxIn -> Mutation

-- | Adds given UTxO to the transaction's inputs and UTxO context.
AddInput :: TxIn -> TxOut CtxUTxO -> Maybe HashableScriptData -> Mutation

-- | Change an input's <a>TxOut</a> to something else. This mutation alters
--   the redeemers of the transaction to ensure any matching redeemer for
--   given input matches the new redeemer, otherwise the transaction would
--   be invalid for the wrong reason (unused redeemer).
--   
--   This expects <a>Nothing</a> if the new input is not locked by any
--   script, and it expects <a>Just</a> with some potentially new redeemer
--   if locked by a script.
--   
--   XXX: This is likely incomplete as it can not add the datum for given
--   txout.
ChangeInput :: TxIn -> TxOut CtxUTxO -> Maybe HashableScriptData -> Mutation

-- | Change the transaction's output at given index to something else.
ChangeOutput :: Word -> TxOut CtxTx -> Mutation

-- | Change the transaction's minted values if it is actually minting
--   something. NOTE: If <a>Value</a> is <a>mempty</a> the redeemers will
--   be wrong.
ChangeMintedValue :: Value -> Mutation

-- | Change required signers on a transaction'
ChangeRequiredSigners :: [Hash PaymentKey] -> Mutation

-- | Change the validity interval of the transaction.
ChangeValidityInterval :: (TxValidityLowerBound, TxValidityUpperBound) -> Mutation
ChangeValidityLowerBound :: TxValidityLowerBound -> Mutation
ChangeValidityUpperBound :: TxValidityUpperBound -> Mutation

-- | Change the included minting policy (the first minted policy) and
--   update minted/burned and output values of this policy.
ChangeMintingPolicy :: PlutusScript -> Mutation

-- | Applies several mutations as a single atomic <a>Mutation</a>. This is
--   useful to enable specific mutations that require consistent change of
--   more than one thing in the transaction and/or UTxO set, for example to
--   change consistently the Head script's redeemer and datum.
Changes :: [Mutation] -> Mutation

-- | Apply a single <a>Mutation</a> to the given (transaction, UTxO) pair.
--   ''<tt>NOTE''</tt>: This function is partial, it can raise <a>error</a>
--   when some preconditions are not met by the transaction or UTxO set,
--   for example if there's no Head script input or no datums in the
--   transaction.
applyMutation :: Mutation -> (Tx, UTxO) -> (Tx, UTxO)

-- | Identify Head script's output.
isHeadOutput :: TxOut CtxUTxO -> Bool

-- | Adds given <tt>Datum</tt> and corresponding hash to the transaction's
--   scripts. TODO: As we are creating the <a>TxOutDatum</a> from a known
--   datum, passing a <a>TxOutDatum</a> is pointless and requires more work
--   than needed to check impossible variants.
addDatum :: TxOutDatum CtxTx -> TxBodyScriptData -> TxBodyScriptData
changeHeadOutputDatum :: (State -> State) -> TxOut CtxTx -> TxOut CtxTx
addParticipationTokens :: [Party] -> TxOut CtxUTxO -> TxOut CtxUTxO

-- | Ensures the included datums of given <a>TxOut</a>s are included in the
--   transactions' <a>TxBodyScriptData</a>.
ensureDatums :: [TxOut CtxTx] -> TxBodyScriptData -> TxBodyScriptData

-- | Alter a transaction's redeemers map given some mapping function.
alterRedeemers :: (RdmrPtr -> (Data LedgerEra, ExUnits) -> (Data LedgerEra, ExUnits)) -> TxBodyScriptData -> TxBodyScriptData

-- | Alter the tx inputs in such way that redeemer pointer stay consistent.
--   A value of <a>Nothing</a> for the redeemr means that this is not a
--   script input. NOTE: This will reset all the execution budgets to 0.
alterTxIns :: ([(TxIn, Maybe HashableScriptData)] -> [(TxIn, Maybe HashableScriptData)]) -> Tx -> Tx

-- | Apply some mapping function over a transaction's outputs.
alterTxOuts :: ([TxOut CtxTx] -> [TxOut CtxTx]) -> Tx -> Tx

-- | Generates an output that pays to some arbitrary pubkey.
anyPayToPubKeyTxOut :: Gen (TxOut ctx)

-- | Finds the Head script's input in given <a>UTxO'</a> set.
--   ''<tt>NOTE''</tt>: This function is partial, it assumes the
--   <a>UTxO'</a> set contains a Head script output.
headTxIn :: UTxO -> TxIn

-- | A <a>Mutation</a> that changes the minted/burnt quantity of all tokens
--   to a non-zero value different than the given one.
changeMintedValueQuantityFrom :: Tx -> Integer -> Gen Mutation

-- | A <a>Mutation</a> that changes the minted/burned quantity of tokens
--   like this: - when no value is being minted/burned -&gt; add a value -
--   when tx is minting or burning values -&gt; add more values on top of
--   that
changeMintedTokens :: Tx -> Value -> Gen Mutation

-- | A <a>Mutation</a> that adds an <a>Arbitrary</a> participation token
--   with some quantity. As usual the quantity can be positive for minting,
--   or negative for burning.
addPTWithQuantity :: Tx -> Quantity -> Gen Mutation

-- | Replace first given <a>PolicyId</a> with the second argument in the
--   whole <a>TxOut</a> value.
replacePolicyIdWith :: PolicyId -> PolicyId -> TxOut a -> TxOut a

-- | Replace first given <a>PolicyId</a> with the second argument in the
--   whole <a>Value</a>.
replacePolicyInValue :: PolicyId -> PolicyId -> Value -> Value
replaceSnapshotNumber :: SnapshotNumber -> State -> State
replaceParties :: [Party] -> State -> State
replaceUtxoHash :: Hash -> State -> State
replaceContestationDeadline :: POSIXTime -> State -> State
replaceContestationPeriod :: ContestationPeriod -> State -> State
replaceHeadId :: CurrencySymbol -> State -> State
replaceContesters :: [PubKeyHash] -> State -> State
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Mutation.Mutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Mutation.Mutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Mutation.SomeMutation
instance GHC.Classes.Eq Hydra.Contract.HeadState.Input
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Contract.HeadState.Input
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Contract.HeadState.State


-- | Mutation-based script validator tests for the init transaction where a
--   <a>healthyInitTx</a> gets mutated by an arbitrary <a>InitMutation</a>.
module Hydra.Chain.Direct.Contract.Init
healthyInitTx :: (Tx, UTxO)
healthyHeadParameters :: HeadParameters
healthySeedInput :: TxIn
healthyParties :: [Party]
healthyCardanoKeys :: [VerificationKey PaymentKey]
healthyLookupUTxO :: UTxO
data InitMutation

-- | Mint more than one ST and PTs.
MintTooManyTokens :: InitMutation
MutateAddAnotherPT :: InitMutation
MutateDropInitialOutput :: InitMutation
MutateDropSeedInput :: InitMutation
MutateInitialOutputValue :: InitMutation
MutateHeadIdInDatum :: InitMutation
MutateSeedInDatum :: InitMutation
data ObserveInitMutation
MutateSomePT :: ObserveInitMutation
genInitMutation :: (Tx, UTxO) -> Gen SomeMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Init.InitMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Init.InitMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Init.InitMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Init.InitMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Init.ObserveInitMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Init.ObserveInitMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Init.ObserveInitMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Init.ObserveInitMutation

module Hydra.Chain.Direct.Contract.FanOut
healthyFanoutTx :: (Tx, UTxO)
healthyFanoutUTxO :: UTxO
healthySlotNo :: SlotNo
healthyContestationDeadline :: UTCTime
healthyFanoutDatum :: State
data FanoutMutation
MutateAddUnexpectedOutput :: FanoutMutation
MutateChangeOutputValue :: FanoutMutation
MutateValidityBeforeDeadline :: FanoutMutation
genFanoutMutation :: (Tx, UTxO) -> Gen SomeMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.FanOut.FanoutMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.FanOut.FanoutMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.FanOut.FanoutMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.FanOut.FanoutMutation

module Hydra.Chain.Direct.Contract.CollectCom
healthyCollectComTx :: (Tx, UTxO)
healthyCommits :: Map TxIn HealthyCommit
healthyCommittedUTxO :: [UTxO]
healthyContestationPeriod :: ContestationPeriod
healthyHeadInput :: TxIn
healthyHeadResolvedInput :: TxOut CtxUTxO
healthyCollectComInitialDatum :: State
healthyOnChainParties :: [Party]
healthyParties :: [Party]
genCommittableTxOut :: Gen (TxIn, TxOut CtxUTxO)
data HealthyCommit
HealthyCommit :: VerificationKey PaymentKey -> TxOut CtxUTxO -> HashableScriptData -> HealthyCommit
[$sel:cardanoKey:HealthyCommit] :: HealthyCommit -> VerificationKey PaymentKey
[$sel:txOut:HealthyCommit] :: HealthyCommit -> TxOut CtxUTxO
[$sel:scriptData:HealthyCommit] :: HealthyCommit -> HashableScriptData
healthyCommitOutput :: Party -> UTxO -> (TxIn, HealthyCommit)
data CollectComMutation

-- | Ensures collectCom does not allow any output address but νHead.
NotContinueContract :: CollectComMutation

-- | Needs to prevent that not all value is collected into the head output.
ExtractSomeValue :: CollectComMutation
MutateOpenUTxOHash :: CollectComMutation

-- | Ensures collectCom cannot collect from an initial UTxO.
MutateCommitToInitial :: CollectComMutation

-- | Every party should have commited and been taken into account for the
--   collectCom transaction to be valid. Here we increase the number of
--   parties in input and output but keep the commits unchanged. This
--   simulates the situation where one participant would not have commited
--   already or whose commit would have been ignored by the collectCom
--   transaction.
MutateNumberOfParties :: CollectComMutation
MutateHeadId :: CollectComMutation
MutateRequiredSigner :: CollectComMutation

-- | Minting or burning of tokens should not be possible in collectCom.
MutateTokenMintingOrBurning :: CollectComMutation
genCollectComMutation :: (Tx, UTxO) -> Gen SomeMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.CollectCom.HealthyCommit
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.CollectCom.CollectComMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.CollectCom.CollectComMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.CollectCom.CollectComMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.CollectCom.CollectComMutation

module Hydra.Chain.Direct.HandlersSpec
genTimeHandleWithSlotInsideHorizon :: Gen (TimeHandle, SlotNo)
genTimeHandleWithSlotPastHorizon :: Gen (TimeHandle, SlotNo)
spec :: Spec

-- | Create a chain sync handler which records events as they are called
--   back.
recordEventsHandler :: ChainContext -> ChainStateAt -> GetTimeHandle IO -> IO (ChainSyncHandler IO, IO [ChainEvent Tx])

-- | A block used for testing. This is a simpler version of the cardano-api
--   <tt>Block</tt> and can be de-/constructed easily.
data TestBlock
TestBlock :: BlockHeader -> [Tx] -> TestBlock
withCounterExample :: [TestBlock] -> TVar IO ChainStateAt -> IO a -> PropertyM IO a

-- | Thin wrapper which generates a <a>TestBlock</a> at some specific slot.
genBlockAt :: SlotNo -> [Tx] -> Gen TestBlock

-- | Pick a block point in a list of blocks.
genRollbackPoint :: [TestBlock] -> Gen ChainPoint

-- | Pick a rollback point from a list of blocks and also yield the tail of
--   blocks to be replayed.
genRollbackBlocks :: [TestBlock] -> Gen (ChainPoint, [TestBlock])

-- | Generate a non-sparse sequence of blocks each containing an observable
--   transaction, starting from the returned on-chain head state.
--   
--   Note that this does not generate the entire spectrum of observable
--   transactions in Hydra, but only init and commits, which is already
--   sufficient to observe at least one state transition and different
--   levels of rollback.
genSequenceOfObservableBlocks :: Gen (ChainContext, ChainStateAt, [TestBlock])
showRollbackInfo :: (Word, ChainPoint) -> String

module Hydra.Chain.Direct.ScriptRegistrySpec
spec :: Spec

module Hydra.Chain.Direct.StateSpec
spec :: Spec
genAdaOnlyUTxOOnMainnetWithAmountBiggerThanOutLimit :: Gen UTxO
prop_canCloseFanoutEveryCollect :: Property
propBelowSizeLimit :: Natural -> ((UTxO -> Tx -> Property) -> Property) -> SpecWith ()
propIsValid :: ((UTxO -> Tx -> Property) -> Property) -> SpecWith ()
forAllInit :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCommit :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCommit' :: Testable property => (ChainContext -> InitialState -> UTxO -> Tx -> property) -> Property
forAllAbort :: Testable property => (UTxO -> Tx -> property) -> Property
forAllCollectCom :: Testable property => (UTxO -> Tx -> property) -> Property
forAllClose :: Testable property => (UTxO -> Tx -> property) -> Property
forAllContest :: Testable property => (UTxO -> Tx -> property) -> Property
forAllFanout :: Testable property => (UTxO -> Tx -> property) -> Property
mfail :: MonadFail m => Maybe a -> m a

module Hydra.Chain.Direct.TimeHandleSpec
spec :: Spec


-- | Unit tests for our "hand-rolled" transactions as they are used in the
--   "direct" chain component.
module Hydra.Chain.Direct.TxSpec
spec :: Spec
ledgerPParams :: BabbagePParams LedgerEra
withinTxExecutionBudget :: EvaluationReport -> Property

-- | Generate a UTXO representing <i>commit</i> outputs for a given list of
--   <a>Party</a>. NOTE: Uses <a>testPolicyId</a> for the datum. NOTE: We
--   don't generate empty commits and it is used only at one place so
--   perhaps move it? FIXME: This function is very complicated and it's
--   hard to understand it after a while
generateCommitUTxOs :: [Party] -> Gen (Map TxIn (TxOut CtxUTxO, HashableScriptData, UTxO))
prettyEvaluationReport :: EvaluationReport -> String
genAbortableOutputs :: [Party] -> Gen ([UTxOWithScript], [(TxIn, TxOut CtxUTxO, HashableScriptData, UTxO)])
fst3 :: (a, b, c) -> a
third :: (a, b, c) -> c
drop2nd :: (a, b, c) -> (a, c)
drop3rd :: (a, b, c) -> (a, b)
tripleToPair :: (a, b, c) -> (a, (b, c))


-- | Mutation-based script validator tests for the commit transaction where
--   a <a>healthyCommitTx</a> gets mutated by an arbitrary
--   <a>CommitMutation</a>.
module Hydra.Chain.Direct.Contract.Commit
healthyCommitTx :: (Tx, UTxO)
commitVerificationKey :: VerificationKey PaymentKey
healthyIntialTxIn :: TxIn
healthyInitialTxOut :: TxOut CtxTx
healthyCommittedUTxO :: UTxO
data CommitMutation

-- | The headId in the output datum must match the one from the input
--   datum.
NonContinuousHeadId :: CommitMutation

-- | Invalidates the transaction by changing the committed output value.
MutateCommitOutputValue :: CommitMutation

-- | Invalidates the transaction by changing the value of the committed
--   utxo on the input side of the transaction.
MutateCommittedValue :: CommitMutation

-- | Ensures the datum recording the commit is consistent with the UTxO
--   being committed.
MutateCommittedAddress :: CommitMutation

-- | Ensures a commit cannot be left out when "declared" in the commit
--   transaction output datum.
RecordAllCommittedUTxO :: CommitMutation

-- | Ensures commit is authenticated by a Head party by changing the signer
--   used on the transaction to be the one in the PT.
MutateRequiredSigner :: CommitMutation

-- | Change the head policy id to simulate commit using a PT and signer
--   from a different head. The signer shows a correct signature but from a
--   different head. This will cause the signer to not be present in the
--   participation tokens.
UsePTFromDifferentHead :: CommitMutation

-- | Minting or burning of the tokens should not be possible in commit.
MutateTokenMintingOrBurning :: CommitMutation
genCommitMutation :: (Tx, UTxO) -> Gen SomeMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Commit.CommitMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Commit.CommitMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Commit.CommitMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Commit.CommitMutation

module Hydra.Chain.Direct.WalletSpec
spec :: Spec
setupQuery :: VerificationKey PaymentKey -> IO (ChainQuery IO, QueryPoint -> Expectation)
mockChainQuery :: VerificationKey PaymentKey -> ChainQuery IO
prop_wellSuitedGenerators :: Property
prop_reducesWhenNotOurs :: Property
prop_seenInputsAreConsumed :: Property
prop_balanceTransaction :: Property
isBalanced :: Map TxIn TxOut -> Tx LedgerEra -> Tx LedgerEra -> Property
ledgerPParams :: PParams (ShelleyLedgerEra Era)
prop_picksCorrectUTxOToPayTheFees :: Property
prop_picksLargestUTxOToPayTheFees :: Property

-- | Generate a chain point with a likely invalid block header hash.
genChainPoint :: Gen ChainPoint

-- | Generate a chain point at given slot with a likely invalid block
--   header hash.
genChainPointAt :: SlotNo -> Gen ChainPoint

-- | Generate an arbitrary list of transactions from a UTXO set such that,
--   transactions may *sometimes* consume given UTXO and produce new ones.
--   The generator is geared towards certain use-cases,
genTxsSpending :: Map TxIn TxOut -> Gen [Tx LedgerEra]
genUTxO :: Gen (Map TxIn TxOut)
genMarkedUTxO :: Gen (Map TxIn TxOut)
genOutputsForInputs :: Tx LedgerEra -> Gen (Map TxIn TxOut)
genLedgerTx :: Gen (Tx LedgerEra)
allTxIns :: [Tx LedgerEra] -> Set TxIn
allTxOuts :: [Tx LedgerEra] -> [TxOut]
isOurs :: Map TxIn TxOut -> Address -> Bool
ourDirectInputs :: Map TxIn TxOut -> [Tx LedgerEra] -> [TxIn]
ourOutputs :: Map TxIn TxOut -> [Tx LedgerEra] -> [TxOut]
getValue :: TxOut -> Value LedgerEra
deltaValue :: Value LedgerEra -> Value LedgerEra -> Value LedgerEra

-- | NOTE: This does not account for withdrawals
knownInputBalance :: Map TxIn TxOut -> Tx LedgerEra -> Value LedgerEra

-- | NOTE: This does not account for deposits
outputBalance :: Tx LedgerEra -> Value LedgerEra

module Hydra.Ledger.SimpleSpec
spec :: Spec
prop_validateCorrectTransactions :: Property
shrinkSequence :: [SimpleTx] -> [[SimpleTx]]


-- | A simplistic type of transactions useful for modelling purpose. a
--   <a>Payment</a> is a simple transaction type that moves some amount of
--   ADAs between to <a>CardanoSigningKey</a>.
module Hydra.Model.Payment
newtype CardanoSigningKey
CardanoSigningKey :: SigningKey PaymentKey -> CardanoSigningKey
[signingKey] :: CardanoSigningKey -> SigningKey PaymentKey

-- | A single Ada-payment only transaction in our model.
data Payment
Payment :: CardanoSigningKey -> CardanoSigningKey -> Value -> Payment
[from] :: Payment -> CardanoSigningKey
[to] :: Payment -> CardanoSigningKey
[value] :: Payment -> Value
applyTx :: UTxOType Payment -> Payment -> UTxOType Payment
genAdaValue :: Gen Value
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Model.Payment.Payment
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Model.Payment.Payment
instance GHC.Generics.Generic Hydra.Model.Payment.Payment
instance GHC.Classes.Eq Hydra.Model.Payment.Payment
instance GHC.Show.Show Hydra.Model.Payment.Payment
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Model.Payment.Payment
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Model.Payment.Payment
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Model.Payment.Payment
instance Test.QuickCheck.StateModel.Variables.HasVariables Hydra.Model.Payment.Payment
instance Hydra.Ledger.IsTx Hydra.Model.Payment.Payment
instance GHC.Show.Show Hydra.Model.Payment.CardanoSigningKey
instance GHC.Classes.Eq Hydra.Model.Payment.CardanoSigningKey
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Model.Payment.CardanoSigningKey
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Model.Payment.CardanoSigningKey
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Model.Payment.CardanoSigningKey
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Model.Payment.CardanoSigningKey
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Model.Payment.CardanoSigningKey
instance Test.QuickCheck.Arbitrary.Arbitrary Cardano.Api.Value.Value
instance Cardano.Binary.ToCBOR.ToCBOR Cardano.Api.Value.Value
instance Cardano.Binary.FromCBOR.FromCBOR Cardano.Api.Value.Value

module Hydra.Network.HeartbeatSpec
spec :: Spec
noop :: Monad m => b -> m ()


-- | Test the real networking layer
module Hydra.NetworkSpec
spec :: Spec
withNodeBroadcastingForever :: Network IO Integer -> Integer -> IO b -> IO b
withNodesBroadcastingForever :: [(Network IO Integer, Integer)] -> IO b -> IO b
assertAllnodesReceivedMessagesFromAllOtherNodes :: [(TQueue IO Integer, Integer)] -> IO ()
shouldEventuallyReceive :: TQueue IO Integer -> Integer -> Expectation
prop_canRoundtripCBOREncoding :: (ToCBOR a, FromCBOR a, Eq a, Show a) => a -> Property

module Hydra.OptionsSpec
spec :: Spec
canRoundtripRunOptionsAndPrettyPrinting :: RunOptions -> Property
shouldParse :: [String] -> Command -> Expectation
shouldNotParse :: [String] -> Expectation
defaultRunOptions :: RunOptions

module Hydra.PartySpec
spec :: Spec

module Hydra.PersistenceSpec
spec :: Spec
genPersistenceItem :: Gen Value
genSomeText :: Gen Text
containsNewLine :: [Value] -> Bool

module Paths_hydra_node
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath

module Hydra.JSONSchema

-- | Validate an <a>Arbitrary</a> value against a JSON schema.
--   
--   The second argument is a lens that says which part of the JSON file to
--   use to do the validation, for example:
--   
--   @<tt> key "components" . key "schemas" . key <a>Address</a> </tt>@
--   
--   which selects the JSON schema for <a>Address</a> types in a bigger
--   specification, say an asyncapi description.
prop_validateJSONSchema :: forall a. (ToJSON a, Arbitrary a, Show a) => String -> SpecificationSelector -> Property

-- | Check specification is complete wr.t. to generated data This second
--   sub-property ensures that any key found in the specification
--   corresponds to a constructor in the corresponding data-type. This
--   makes sure the document is kept in sync and make sure we don't left
--   behind constructors which no longer exists.
--   
--   The second argument is a lens that says which part of the
--   specification to select to check completeness of the specification
--   w.r.t. constructors for the datatype, for example:
--   
--   @<tt> key "properties" . key "message" </tt>@
--   
--   which selects the list of elements under <tt>properties &gt;
--   message</tt> path in the specification file. This element should be a
--   schema fragment that has a property <tt>oneOf</tt> containing a list
--   of objects having a <tt>title</tt> property.
--   
--   Given the above selector, this schema fragment is fine:
--   
--   @<tt> properties: message: oneOf: - title: APIServer type: object ...
--   </tt>@
prop_specIsComplete :: forall a. (Arbitrary a, Show a) => String -> SpecificationSelector -> Property

-- | An alias for a traversal selecting some part of a <tt>Value</tt> This
--   alleviates the need for users of this module to import explicitly the
--   types from aeson and lens.
type SpecificationSelector = Traversal' Value Value

-- | Prepare the environment (temp directory) with the JSON specifications.
--   We maintain a YAML version of a JSON-schema, for it is more convenient
--   to write. But tools (and in particular jsonschema) only works from
--   JSON, so this function makes sure to also convert our local yaml into
--   JSON.
withJsonSpecifications :: MonadIO m => (FilePath -> m r) -> m r
addField :: ToJSON a => Key -> a -> Value -> Value

-- | Make sure that the required `check-jsonschema` tool is available on
--   the system. Mark a test as pending when not available.
ensureSystemRequirements :: IO ()

module Hydra.LoggingSpec
spec :: Spec

module Hydra.API.RestServerSpec
spec :: Spec


-- | Test and example values used across hydra-node tests.
module Test.Hydra.Fixture
alice :: Party
bob :: Party
carol :: Party
aliceSk :: SigningKey HydraKey
bobSk :: SigningKey HydraKey
carolSk :: SigningKey HydraKey
aliceVk :: VerificationKey HydraKey
bobVk :: VerificationKey HydraKey
carolVk :: VerificationKey HydraKey
allVKeys :: [VerificationKey HydraKey]
cperiod :: ContestationPeriod

module Hydra.NodeSpec
spec :: Spec
isReqSn :: Message tx -> Bool
eventsToOpenHead :: [Event SimpleTx]
runToCompletion :: IsChainState tx => Tracer IO (HydraNodeLog tx) -> HydraNode tx IO -> IO ()
createHydraNode :: (MonadDelay m, MonadAsync m, MonadThrow m, MonadLabelledSTM m) => SigningKey HydraKey -> [Party] -> ContestationPeriod -> [Event SimpleTx] -> m (HydraNode SimpleTx m)
recordNetwork :: HydraNode tx IO -> IO (HydraNode tx IO, IO [Message tx])
recordServerOutputs :: HydraNode tx IO -> IO (HydraNode tx IO, IO [ServerOutput tx])
messageRecorder :: IO (msg -> IO (), IO [msg])
throwExceptionOnPostTx :: IsChainState tx => PostTxError tx -> HydraNode tx IO -> IO (HydraNode tx IO)

module Hydra.Network.AuthenticateSpec
spec :: Spec
newtype Msg
Msg :: ByteString -> Msg
instance Cardano.Crypto.Util.SignableRepresentation Hydra.Network.AuthenticateSpec.Msg
instance Cardano.Binary.FromCBOR.FromCBOR Hydra.Network.AuthenticateSpec.Msg
instance Cardano.Binary.ToCBOR.ToCBOR Hydra.Network.AuthenticateSpec.Msg
instance GHC.Show.Show Hydra.Network.AuthenticateSpec.Msg
instance GHC.Classes.Eq Hydra.Network.AuthenticateSpec.Msg
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Network.AuthenticateSpec.Msg


-- | Unit tests of the the protocol logic in <tt>HeadLogic</tt>. These are
--   very fine grained and specific to individual steps in the protocol.
--   More high-level of the protocol logic, especially between multiple
--   parties can be found in <a>BehaviorSpec</a>.
module Hydra.HeadLogicSpec
spec :: Spec
runEvents :: Monad m => Environment -> Ledger tx -> HeadState tx -> StateT (StepState tx) m a -> m a

-- | Create a chain effect with fixed chain state and slot.
chainEffect :: PostChainTx SimpleTx -> Effect SimpleTx
observeEventAtSlot :: Natural -> OnChainTx SimpleTx -> Event SimpleTx

-- | Create an observation event with fixed chain state and slot.
observationEvent :: OnChainTx SimpleTx -> Event SimpleTx
inInitialState :: [Party] -> HeadState SimpleTx
inOpenState :: [Party] -> Ledger SimpleTx -> HeadState SimpleTx
inOpenState' :: [Party] -> CoordinatedHeadState SimpleTx -> HeadState SimpleTx
inClosedState :: [Party] -> HeadState SimpleTx
inClosedState' :: [Party] -> ConfirmedSnapshot SimpleTx -> HeadState SimpleTx
getConfirmedSnapshot :: HeadState tx -> Maybe (Snapshot tx)
data StepState tx
StepState :: HeadState tx -> Environment -> Ledger tx -> StepState tx
[$sel:headState:StepState] :: StepState tx -> HeadState tx
[$sel:env:StepState] :: StepState tx -> Environment
[$sel:ledger:StepState] :: StepState tx -> Ledger tx

-- | Asserts that the update function will update the state (return a
--   NewState) for this Event
step :: (MonadState (StepState tx) m, HasCallStack, IsChainState tx) => Event tx -> m (HeadState tx)

-- | Asserts that the update function will update the state (return a
--   NewState) for this Event
assertUpdateState :: (MonadState (HeadState tx) m, HasCallStack, IsChainState tx) => Environment -> Ledger tx -> Event tx -> m (HeadState tx)
assertNewState :: (HasCallStack, IsChainState tx, Monad m) => Outcome tx -> m (HeadState tx)
assertEffects :: (HasCallStack, IsChainState tx) => Outcome tx -> IO ()
hasEffect :: (HasCallStack, IsChainState tx) => Outcome tx -> Effect tx -> IO ()
hasWait :: (HasCallStack, IsChainState tx) => Outcome tx -> WaitReason tx -> IO ()
hasEffectSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (Effect tx -> Bool) -> IO ()
hasNoEffectSatisfying :: (HasCallStack, IsChainState tx) => Outcome tx -> (Effect tx -> Bool) -> IO ()
testHeadId :: HeadId

module Hydra.HeadLogicSnapshotSpec
spec :: Spec
prop_singleMemberHeadAlwaysSnapshotOnReqTx :: ConfirmedSnapshot SimpleTx -> Property
prop_thereIsAlwaysALeader :: Property

module Hydra.Chain.Direct.Contract.Contest

-- | Healthy contest tx where the contester is the first one to contest and
--   correctly pushing out the deadline by the contestation period.
healthyContestTx :: (Tx, UTxO)
healthyClosedHeadTxIn :: TxIn
healthyClosedHeadTxOut :: TxOut CtxUTxO
healthyContestSnapshot :: Snapshot Tx
healthyContestSnapshotNumber :: SnapshotNumber
healthyContestUTxO :: UTxO
healthyContestUTxOHash :: BuiltinByteString
healthyClosedState :: State
healthySlotNo :: SlotNo
healthyContestationDeadline :: UTCTime
healthyOnChainContestationPeriod :: ContestationPeriod
healthyContestationPeriod :: ContestationPeriod
healthyContestationPeriodSeconds :: Integer
healthyClosedSnapshotNumber :: SnapshotNumber
healthyClosedUTxOHash :: BuiltinByteString
healthyClosedUTxO :: UTxO
healthyContesterVerificationKey :: VerificationKey PaymentKey
healthySigningKeys :: [SigningKey HydraKey]
healthyParties :: [Party]
healthyOnChainParties :: [Party]
healthySignature :: SnapshotNumber -> MultiSignature (Snapshot Tx)
data ContestMutation

-- | Ensures collectCom does not allow any output address but νHead.
NotContinueContract :: ContestMutation

-- | Invalidates the tx by changing the redeemer signature but not the
--   snapshot number in resulting head output.
--   
--   Ensures the snapshot signature is multisigned by all valid Head
--   participants.
MutateSignatureButNotSnapshotNumber :: ContestMutation

-- | Invalidates the tx by changing the snapshot number in resulting head
--   output but not the redeemer signature.
--   
--   Ensures the snapshot signature is aligned with snapshot number.
MutateSnapshotNumberButNotSignature :: ContestMutation

-- | Invalidates the tx by changing the contest snapshot number too old.
--   
--   This is achieved by updating the head input datum to be older, so the
--   healthy snapshot number becomes too old.
MutateToNonNewerSnapshot :: ContestMutation

-- | Ensures close is authenticated by one of the Head members by changing
--   the signer used on the tx to be not one of PTs.
MutateRequiredSigner :: ContestMutation

-- | Ensures close is authenticated by one of the Head members by changing
--   the signer used on the tx to be empty.
MutateNoRequiredSigner :: ContestMutation

-- | Ensures close is authenticated by one of the Head members by changing
--   the signer used on the tx to have multiple signers (including the
--   signer to not fail for SignerIsNotAParticipant).
MutateMultipleRequiredSigner :: ContestMutation

-- | Invalidates the tx by changing the utxo hash in resulting head output.
--   
--   Ensures the output state is consistent with the redeemer.
MutateContestUTxOHash :: ContestMutation

-- | Ensures the contest snapshot is multisigned by all Head participants
--   by changing the parties in the input head datum. If they do not align
--   the multisignature will not be valid anymore.
SnapshotNotSignedByAllParties :: ContestMutation

-- | Invalidates the tx by changing the upper bound to be beyond
--   contestation deadline from head input (stored state).
MutateValidityPastDeadline :: ContestMutation

-- | Change the head policy id to simulate contestation using a ST and
--   signer from a different head. The signer shows a correct signature but
--   from a different head. This will cause the signer to not be present in
--   the participation tokens.
ContestFromDifferentHead :: ContestMutation

-- | Minting or burning of tokens should not be possible in contest.
MutateTokenMintingOrBurning :: ContestMutation

-- | Ensures a participant can only contest once by changing the head input
--   datum to already include the signer.
MutateInputContesters :: ContestMutation

-- | Ensures a the signer needs to be added to the head output datum.
MutateContesters :: ContestMutation

-- | Invalidates the tx by changing the output values arbitrarily to be
--   different (not preserved) from the head.
--   
--   Ensures values are preserved between head input and output.
MutateValueInOutput :: ContestMutation

-- | Not pushing the contestation deadline in head output datum should not
--   be allowed.
NotUpdateDeadlineAlthoughItShould :: ContestMutation

-- | Pushes the deadline although this is the last contest. Instead of
--   creating another healthy case and mutate that one, this mutation just
--   changes the starting situation so that everyone else already
--   contested. Remember the <a>healthyContestTx</a> is already pushing out
--   the deadline.
PushDeadlineAlthoughItShouldNot :: ContestMutation

-- | Ensures contestation period does not change between head input datum
--   and head output datum.
MutateOutputContestationPeriod :: ContestMutation

-- | Ensures parties do not change between head input datum and head output
--   datum.
MutatePartiesInOutput :: ContestMutation

-- | Ensures headId do not change between head input datum and head output
--   datum.
MutateHeadIdInOutput :: ContestMutation
genContestMutation :: (Tx, UTxO) -> Gen SomeMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Contest.ContestMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Contest.ContestMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Contest.ContestMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Contest.ContestMutation

module Hydra.Chain.Direct.Contract.Close

-- | Healthy close transaction for the generic case were we close a head
--   after one or more snapshot have been agreed upon between the members.
healthyCloseTx :: (Tx, UTxO)

-- | Healthy close transaction for the specific case were we close a head
--   with the initial UtxO, that is, no snapshot have been agreed upon and
--   signed by the head members yet.
healthyCloseInitialTx :: (Tx, UTxO)
healthyCloseLowerBoundSlot :: SlotNo
healthyCloseUpperBoundPointInTime :: PointInTime
healthyOpenHeadTxIn :: TxIn
healthyOpenHeadTxOut :: TxOut CtxUTxO
healthySnapshot :: Snapshot Tx
healthyCloseUTxO :: UTxO
healthyCloseSnapshotNumber :: SnapshotNumber
healthyOpenHeadDatum :: State
healthyContestationPeriod :: ContestationPeriod
healthyContestationPeriodSeconds :: Integer
healthyUTxO :: UTxO
somePartyCardanoVerificationKey :: VerificationKey PaymentKey
healthySigningKeys :: [SigningKey HydraKey]
healthyParties :: [Party]
healthyOnChainParties :: [Party]
healthySignature :: SnapshotNumber -> MultiSignature (Snapshot Tx)
healthyContestationDeadline :: UTCTime
healthyClosedUTxOHash :: BuiltinByteString
healthyClosedUTxO :: UTxO
data CloseMutation

-- | Ensures collectCom does not allow any output address but νHead.
NotContinueContract :: CloseMutation

-- | Ensures the snapshot signature is multisigned by all valid Head
--   participants.
--   
--   Invalidates the tx by changing the redeemer signature but not the
--   snapshot number in output head datum.
MutateSignatureButNotSnapshotNumber :: CloseMutation

-- | Ensures the snapshot number is consistent with the signature.
--   
--   Invalidates the tx by changing the snapshot number in resulting head
--   output but not the redeemer signature.
MutateSnapshotNumberButNotSignature :: CloseMutation

-- | Check that snapshot numbers &lt;= 0 need to close the head with the
--   initial UTxO hash.
MutateSnapshotNumberToLessThanEqualZero :: CloseMutation

-- | Ensures the close snapshot is multisigned by all Head participants by
--   changing the parties in the input head datum. If they do not align the
--   multisignature will not be valid anymore.
SnapshotNotSignedByAllParties :: CloseMutation

-- | Ensures close is authenticated by a one of the Head members by
--   changing the signer used on the tx to not be one of PTs.
MutateRequiredSigner :: CloseMutation

-- | Ensures close is authenticated by a one of the Head members by
--   changing the signer used on the tx to be empty.
MutateNoRequiredSigner :: CloseMutation

-- | Ensures close is authenticated by a one of the Head members by
--   changing the signer used on the tx to have multiple signers (including
--   the signer to not fail for SignerIsNotAParticipant).
MutateMultipleRequiredSigner :: CloseMutation

-- | Invalidates the tx by changing the utxo hash in resulting head output.
--   
--   Ensures the output state is consistent with the redeemer.
MutateCloseUTxOHash :: CloseMutation

-- | Ensures parties do not change between head input datum and head output
--   datum.
MutatePartiesInOutput :: CloseMutation

-- | Ensures headId do not change between head input datum and head output
--   datum.
MutateHeadIdInOutput :: CloseMutation

-- | Invalidates the tx by changing the lower bound to be non finite.
MutateInfiniteLowerBound :: CloseMutation

-- | Invalidates the tx by changing the upper bound to be non finite.
MutateInfiniteUpperBound :: CloseMutation

-- | Invalidates the tx by changing the contestation deadline to not
--   satisfy `contestationDeadline = upperBound + contestationPeriod`.
MutateContestationDeadline :: CloseMutation

-- | Invalidates the tx by changing the lower and upper bound to be not
--   bounded as per spec `upperBound - lowerBound &lt;=
--   contestationPeriod`.
--   
--   This also changes the resulting `head output` contestation deadline to
--   be valid, so it satisfy `contestationDeadline = upperBound +
--   contestationPeriod`.
MutateValidityInterval :: CloseMutation

-- | Ensure the Head cannot be closed with correct authentication from a
--   different Head. We simulate this by changing the head policy id of the
--   ST and PTs to be of a different head - a real attack would be to add
--   inputs with those tokens on top of spending the head output, a bit
--   like a double satisfaction attack. Note that the token name stays the
--   same and consistent with the signer. This will cause authentication
--   failure because the signer's PT, although with a consistent name, is
--   not from the right head (has a different policy id than in the datum).
CloseFromDifferentHead :: CloseMutation

-- | Minting or burning of tokens should not be possible in close.
MutateTokenMintingOrBurning :: CloseMutation

-- | Invalidates the tx by changing the contesters to be non empty.
MutateContesters :: CloseMutation

-- | Invalidates the tx by changing output values arbitrarily to be
--   different (not preserved) from the head.
--   
--   Ensures values are preserved between head input and output.
MutateValueInOutput :: CloseMutation
genCloseMutation :: (Tx, UTxO) -> Gen SomeMutation
data CloseInitialMutation
MutateCloseContestationDeadline' :: CloseInitialMutation

-- | Mutations for the specific case of closing with the intial state. We
--   should probably validate all the mutation to this initial state but at
--   least we keep this regression test as we stumbled upon problems with
--   the following case. The nice thing to do would probably to generate
--   either "normal" healthyCloseTx or or healthyCloseInitialTx and apply
--   all the mutations to it but we didn't manage to do that right away.
genCloseInitialMutation :: (Tx, UTxO) -> Gen SomeMutation

-- | Generate not acceptable, but interesting deadlines.
genMutatedDeadline :: Gen POSIXTime
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Close.CloseMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Close.CloseMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Close.CloseMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Close.CloseMutation
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Close.CloseInitialMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Close.CloseInitialMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Close.CloseInitialMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Close.CloseInitialMutation


-- | Mutation-based script validator tests for the abort transaction where
--   a <a>healthyAbortTx</a> gets mutated by an arbitrary
--   <a>AbortMutation</a>.
module Hydra.Chain.Direct.Contract.Abort
healthyAbortTx :: HasCallStack => (Tx, UTxO)
healthyHeadInput :: TxIn
healthyHeadParameters :: HeadParameters
healthyInitials :: [UTxOWithScript]
healthyCommits :: [(TxIn, TxOut CtxUTxO, HashableScriptData, UTxO)]
healthyParties :: [Party]
propHasInitial :: (Tx, UTxO) -> Property
propHasCommit :: (Tx, UTxO) -> Property
data AbortMutation

-- | Add one more party to the hydra keys. This is essentialy the same as
--   not collecting all inputs.
MutateParties :: AbortMutation

-- | Not collect one committed UTxO by removing the input and not burn the
--   corresponding PT.
DropCollectedInput :: AbortMutation

-- | Not reimburse one of the parties.
DropOneCommitOutput :: AbortMutation

-- | Burning one PT more. This should be an impossible situation, but it is
--   tested nontheless.
BurnOneTokenMore :: AbortMutation

-- | Meant to test that the minting policy is burning all PTs present in tx
MutateThreadTokenQuantity :: AbortMutation

-- | Check an arbitrary key cannot authenticate abort.
MutateRequiredSigner :: AbortMutation

-- | Use a different head output to abort.
MutateUseDifferentHeadToAbort :: AbortMutation

-- | Spend some abortable output from a different Head e.g. replace a
--   commit by another commit from a different Head.
UseInputFromOtherHead :: AbortMutation

-- | Re-ordering outputs would not be a big deal, but it is still
--   prevented.
ReorderCommitOutputs :: AbortMutation

-- | Only burning should be allowed in abort (by the minting policy).
MintOnAbort :: AbortMutation
genAbortMutation :: (Tx, UTxO) -> Gen SomeMutation
removePTFromMintedValue :: TxOut CtxUTxO -> Tx -> Value
instance GHC.Enum.Bounded Hydra.Chain.Direct.Contract.Abort.AbortMutation
instance GHC.Enum.Enum Hydra.Chain.Direct.Contract.Abort.AbortMutation
instance GHC.Show.Show Hydra.Chain.Direct.Contract.Abort.AbortMutation
instance GHC.Generics.Generic Hydra.Chain.Direct.Contract.Abort.AbortMutation

module Hydra.Chain.Direct.ContractSpec
spec :: Spec
prop_serializingCommitRoundtrip :: Property
prop_consistentOnAndOffChainHashOfTxOuts :: Property
prop_consistentHashPreSerializedCommits :: Property
prop_hashingCaresAboutOrderingOfTxOuts :: Property
prop_verifyOffChainSignatures :: Property
prop_verifySnapshotSignatures :: Property

module Hydra.API.ServerSpec
spec :: Spec
strictlyMonotonic :: (Eq a, Enum a) => [a] -> Bool
sendsAnErrorWhenInputCannotBeDecoded :: PortNumber -> Expectation
matchGreetings :: Value -> Bool
isGreetings :: ServerOutput tx -> Bool
waitForClients :: (MonadSTM m, Ord a, Num a) => TVar m a -> m ()
testClient :: TQueue IO (ServerOutput SimpleTx) -> TVar IO Int -> Connection -> IO ()
dummyChainHandle :: Chain tx IO
noop :: Applicative m => a -> m ()
withTestAPIServer :: PortNumber -> Party -> PersistenceIncremental (TimedServerOutput SimpleTx) IO -> Tracer IO APIServerLog -> (Server SimpleTx IO -> IO ()) -> IO ()
withClient :: PortNumber -> String -> (Connection -> IO ()) -> IO ()

-- | Mocked persistence handle which just does nothing.
mockPersistence :: Applicative m => PersistenceIncremental a m

-- | Mocked persistence which does not contain some constant elements.
mockPersistence' :: Applicative m => [a] -> PersistenceIncremental a m
waitForValue :: HasCallStack => PortNumber -> (Value -> Maybe ()) -> IO ()

-- | Wait up to some time for an API server output to match the given
--   predicate.
waitMatch :: HasCallStack => Natural -> Connection -> (Value -> Maybe a) -> IO a
shouldSatisfyAll :: Show a => [a] -> [a -> Bool] -> Expectation

module Hydra.Node.EventQueueSpec
spec :: Spec
newtype DummyEvent
DummyEvent :: Int -> DummyEvent
prop_identify_enqueued_events :: NonEmptyList DummyEvent -> Property
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Node.EventQueueSpec.DummyEvent
instance GHC.Show.Show Hydra.Node.EventQueueSpec.DummyEvent
instance GHC.Classes.Eq Hydra.Node.EventQueueSpec.DummyEvent

module Test.Util

-- | Run given <tt>action</tt> in <a>IOSim</a> and rethrow any exceptions.
shouldRunInSim :: (forall s. IOSim s a) -> IO a

-- | Utility function to dump logs given a <a>SimTrace</a>.
printTrace :: forall log a. (Typeable log, ToJSON log) => Proxy log -> SimTrace a -> Text

-- | Lifted variant of Hspec's <a>shouldBe</a>.
shouldBe :: (HasCallStack, MonadThrow m, Eq a, Show a) => a -> a -> m ()

-- | Lifted variant of Hspec's <a>shouldReturn</a>.
shouldReturn :: (HasCallStack, MonadThrow m, Eq a, Show a) => m a -> a -> m ()

-- | Lifted variant of Hspec's <a>shouldSatisfy</a>.
shouldSatisfy :: (HasCallStack, MonadThrow m, Show a) => a -> (a -> Bool) -> m ()

-- | Lifted variant of Hspec's <a>shouldNotBe</a>.
shouldNotBe :: (HasCallStack, MonadThrow m, Eq a, Show a) => a -> a -> m ()

-- | Lifted variant of Hspec's <a>shouldContain</a>.
shouldContain :: (HasCallStack, MonadThrow m, Eq a, Show a) => [a] -> [a] -> m ()

-- | A <a>Tracer</a> that works in <a>IOSim</a> monad. This tracer uses the
--   <tt>Output</tt> event which uses converts value traced to
--   <tt>Dynamic</tt> which requires <a>Typeable</a> constraint. To
--   retrieve the trace use <tt>selectTraceEventsDynamic</tt> applied to
--   the correct type.
traceInIOSim :: Typeable a => Tracer (IOSim s) a

-- | Useful when one needs to <i>also</i> trace logs to <a>stderr</a>.
--   Thanks to the monoidal nature of <a>Tracer</a> it's straightforward to
--   add this to any existing tracer:
--   
--   @<tt> someCode tracer = do foo &lt;- makeFoo withTracer (tr &lt;&gt;
--   traceDebug) SomeTraceFoo ... </tt>@
traceDebug :: (Applicative m, ToJSON a) => Tracer m a

-- | This creates an hspec test case about a property which ensures the
--   given generator does not produce equals values within a reasonable
--   number of generated values.
propCollisionResistant :: (Show a, Eq a) => String -> Gen a -> Spec

module Hydra.Ledger.CardanoSpec
spec :: Spec
shouldParseJSONAs :: forall a. FromJSON a => LByteString -> Expectation
roundtripTxId :: Tx -> Property
roundtripLedger :: Tx -> Property
roundtripCBOR :: (Eq a, Show a, ToCBOR a, FromCBOR a) => a -> Property
appliesValidTransaction :: Property
appliesValidTransactionFromJSON :: Property
propDoesNotCollapse :: (Show (t a), Foldable t, Monoid (t a)) => String -> Gen (t a) -> Spec

-- | Check that the given <a>TxOut</a> fulfills several requirements and
--   does not use unsupported features. See <a>genTxOut</a> for rationale.
prop_generatesGoodTxOut :: TxOut CtxUTxO -> Property

module Hydra.FireForgetSpec
spec :: Spec
client :: Applicative m => FireForgetClient Text m ()
newServer :: forall m. MonadSTM m => m (FireForgetServer Text m Text)

module Hydra.CryptoSpec
spec :: Spec
specSigningKey :: Spec
specVerificationKey :: Spec
specSignature :: Spec
specMultiSignature :: Spec

module Hydra.BehaviorSpec
spec :: Spec

-- | Wait for some output at some node(s) to be produced <i>eventually</i>.
--   See <a>waitUntilMatch</a> for how long it waits.
waitUntil :: (HasCallStack, MonadThrow m, MonadAsync m, MonadTimer m, IsChainState tx) => [TestHydraClient tx m] -> ServerOutput tx -> m ()

-- | Wait for some output to match some predicate <i>eventually</i>. This
--   will not wait forever, but for a long time (1 month) to get a nice
--   error location. Should not be an issue when used within
--   <a>shouldRunInSim</a>, this was even 1000 years before - but we since
--   we are having the protocol produce <a>Tick</a> events constantly this
--   would be fully simulated to the end.
waitUntilMatch :: (HasCallStack, MonadThrow m, MonadAsync m, MonadTimer m) => [TestHydraClient tx m] -> (ServerOutput tx -> Bool) -> m ()

-- | Wait for an output matching the predicate and extracting some value.
--   This will loop forever until a match has been found.
waitMatch :: MonadThrow m => TestHydraClient tx m -> (ServerOutput tx -> Maybe a) -> m a

-- | A thin client layer around <a>HydraNode</a> to be interact with it
--   through <a>$sel:send:TestHydraClient</a>,
--   <a>$sel:waitForNext:TestHydraClient</a>, access all outputs and inject
--   events through the test chain.
data TestHydraClient tx m
TestHydraClient :: (ClientInput tx -> m ()) -> m (ServerOutput tx) -> (ChainEvent tx -> m ()) -> m [ServerOutput tx] -> TestHydraClient tx m
[$sel:send:TestHydraClient] :: TestHydraClient tx m -> ClientInput tx -> m ()
[$sel:waitForNext:TestHydraClient] :: TestHydraClient tx m -> m (ServerOutput tx)
[$sel:injectChainEvent:TestHydraClient] :: TestHydraClient tx m -> ChainEvent tx -> m ()
[$sel:serverOutputs:TestHydraClient] :: TestHydraClient tx m -> m [ServerOutput tx]

-- | A simulated chain that just echoes <a>PostChainTx</a> as
--   <a>Observation</a>s of <a>OnChainTx</a> onto all connected nodes. It
--   can also <a>$sel:rollbackAndForward:SimulatedChainNetwork</a> any
--   number of these "transactions".
data SimulatedChainNetwork tx m
SimulatedChainNetwork :: (HydraNode tx m -> m (HydraNode tx m)) -> Async m () -> (Natural -> m ()) -> SimulatedChainNetwork tx m
[$sel:connectNode:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> HydraNode tx m -> m (HydraNode tx m)
[$sel:tickThread:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> Async m ()
[$sel:rollbackAndForward:SimulatedChainNetwork] :: SimulatedChainNetwork tx m -> Natural -> m ()

-- | With-pattern wrapper around <a>simulatedChainAndNetwork</a> which does
--   <a>cancel</a> the <a>$sel:tickThread:SimulatedChainNetwork</a>. Also,
--   this will fix tx to <a>SimpleTx</a> so that it can pick an initial
--   chain state to play back to our test nodes.
withSimulatedChainAndNetwork :: (MonadTime m, MonadDelay m, MonadAsync m) => (SimulatedChainNetwork SimpleTx m -> m ()) -> m ()

-- | Class to manipulate the chain state by advancing it's slot in
--   <a>simulatedChainAndNetwork</a>.
class IsChainState a => IsChainStateTest a
advanceSlot :: IsChainStateTest a => ChainStateType a -> ChainStateType a

-- | Creates a simulated chain and network to which <a>HydraNode</a>s can
--   be connected to using <a>$sel:connectNode:SimulatedChainNetwork</a>.
--   NOTE: The <a>$sel:tickThread:SimulatedChainNetwork</a> needs to be
--   <a>cancel</a>ed after use. Use <a>withSimulatedChainAndNetwork</a>
--   instead where possible.
simulatedChainAndNetwork :: (MonadTime m, MonadDelay m, MonadAsync m, IsChainStateTest tx) => ChainStateType tx -> m (SimulatedChainNetwork tx m)
handleChainEvent :: HydraNode tx m -> ChainEvent tx -> m ()
createMockNetwork :: MonadSTM m => HydraNode tx m -> TVar m [HydraNode tx m] -> Network m (Message tx)

-- | Derive an <a>OnChainTx</a> from <a>PostChainTx</a> to simulate a
--   "perfect" chain. NOTE(SN): This implementation does *NOT* honor the
--   <a>HeadParameters</a> and announces hard-coded contestationDeadlines.
toOnChainTx :: UTCTime -> PostChainTx tx -> OnChainTx tx
testContestationPeriod :: ContestationPeriod
testHeadId :: HeadId
nothingHappensFor :: (MonadTimer m, MonadThrow m, IsChainState tx) => TestHydraClient tx m -> DiffTime -> m ()
withHydraNode :: forall s a. SigningKey HydraKey -> [Party] -> SimulatedChainNetwork SimpleTx (IOSim s) -> (TestHydraClient SimpleTx (IOSim s) -> IOSim s a) -> IOSim s a
createTestHydraClient :: MonadSTM m => TQueue m (ServerOutput tx) -> TVar m [ServerOutput tx] -> HydraNode tx m -> TestHydraClient tx m
createHydraNode :: (MonadDelay m, MonadAsync m, MonadLabelledSTM m) => Ledger tx -> NodeState tx m -> SigningKey HydraKey -> [Party] -> TQueue m (ServerOutput tx) -> TVar m [ServerOutput tx] -> SimulatedChainNetwork tx m -> ContestationPeriod -> m (HydraNode tx m)
openHead :: TestHydraClient SimpleTx (IOSim s) -> TestHydraClient SimpleTx (IOSim s) -> IOSim s ()
matchFanout :: PostChainTx tx -> Bool
assertHeadIsClosed :: (HasCallStack, MonadThrow m) => ServerOutput tx -> m ()
assertHeadIsClosedWith :: (HasCallStack, MonadThrow m) => SnapshotNumber -> ServerOutput tx -> m ()

-- | Provide a quick and dirty to way to label stuff from a signing key
shortLabel :: SigningKey HydraKey -> String
instance Hydra.BehaviorSpec.IsChainStateTest Hydra.Ledger.Simple.SimpleTx
instance Hydra.BehaviorSpec.IsChainStateTest Hydra.Cardano.Api.Tx

module Hydra.Model.MockChain

-- | Create a mocked chain which connects nodes through
--   <a>ChainSyncHandler</a> and <a>Chain</a> interfaces. It calls
--   connected chain sync handlers
--   <a>$sel:onRollForward:ChainSyncHandler</a> on every <tt>blockTime</tt>
--   and performs <a>$sel:rollbackAndForward:SimulatedChainNetwork</a>
--   every couple blocks.
mockChainAndNetwork :: forall m. (MonadTimer m, MonadAsync m, MonadMask m, MonadThrow (STM m), MonadLabelledSTM m, MonadFork m) => Tracer m DirectChainLog -> [(SigningKey HydraKey, CardanoSigningKey)] -> ContestationPeriod -> m (SimulatedChainNetwork Tx m)

-- | Find Cardano vkey corresponding to our Hydra vkey using signing keys
--   lookup. This is a bit cumbersome and a tribute to the fact the
--   <a>HydraNode</a> itself has no direct knowlege of the cardano keys
--   which are stored only at the <tt>ChainComponent</tt> level.
findOwnCardanoKey :: Party -> [(SigningKey HydraKey, CardanoSigningKey)] -> (VerificationKey PaymentKey, [VerificationKey PaymentKey])
createMockNetwork :: MonadSTM m => HydraNode Tx m -> TVar m [MockHydraNode m] -> Network m (Message Tx)
data MockHydraNode m
MockHydraNode :: HydraNode Tx m -> ChainSyncHandler m -> MockHydraNode m
[$sel:node:MockHydraNode] :: MockHydraNode m -> HydraNode Tx m
[$sel:chainHandler:MockHydraNode] :: MockHydraNode m -> ChainSyncHandler m
createMockChain :: (MonadTimer m, MonadThrow (STM m)) => Tracer m DirectChainLog -> ChainContext -> SubmitTx m -> m TimeHandle -> TxIn -> LocalChainState m -> Chain Tx m
mkMockTxIn :: VerificationKey PaymentKey -> Word -> TxIn


-- | A <i>Model</i> of the Hydra head Protocol.
--   
--   This model integrates in a single state-machine like abstraction the
--   whole behaviour of a Hydra Head, taking into account both on-chain
--   state and contracts, and off-chain interactions. It is written from
--   the point of view of a pre-defined set of Hydra node <i>operators</i>
--   that want to create a channel between them. It's a "happy path" model
--   that does not implement any kind of adversarial behaviour and whose
--   transactions are very simple: Each tx is a payment of one Ada-only
--   UTxO transferred to another party in full, without any change.
--   
--   More intricate and specialised models shall be developed once we get a
--   firmer grasp of the whole framework, injecting faults, taking into
--   account more parts of the stack, modelling more complex transactions
--   schemes...
module Hydra.Model

-- | State maintained by the model.
data WorldState
WorldState :: [(SigningKey HydraKey, CardanoSigningKey)] -> GlobalState -> WorldState

-- | List of parties identified by both signing keys required to run
--   protocol. This list must not contain any duplicated key.
[$sel:hydraParties:WorldState] :: WorldState -> [(SigningKey HydraKey, CardanoSigningKey)]

-- | Expected consensus state All nodes should be in the same state.
[$sel:hydraState:WorldState] :: WorldState -> GlobalState

-- | Global state of the Head protocol. While each participant in the Hydra
--   Head protocol has its own private view of the state, we model the
--   expected global state whose properties stem from the consensus built
--   into the Head protocol. In other words, this state is what each node's
--   local state should be <i>eventually</i>.
data GlobalState

-- | Start of the "world". This state is left implicit in the node's logic
--   as it represents that state where the node does not even exist.
Start :: GlobalState
Idle :: [Party] -> [VerificationKey PaymentKey] -> ContestationPeriod -> GlobalState
[$sel:idleParties:Start] :: GlobalState -> [Party]
[$sel:cardanoKeys:Start] :: GlobalState -> [VerificationKey PaymentKey]
[$sel:idleContestationPeriod:Start] :: GlobalState -> ContestationPeriod
Initial :: HeadParameters -> Committed Payment -> PendingCommits -> GlobalState
[$sel:headParameters:Start] :: GlobalState -> HeadParameters
[$sel:commits:Start] :: GlobalState -> Committed Payment
[$sel:pendingCommits:Start] :: GlobalState -> PendingCommits
Open :: HeadParameters -> OffChainState -> GlobalState
[$sel:headParameters:Start] :: GlobalState -> HeadParameters
[$sel:offChainState:Start] :: GlobalState -> OffChainState
Final :: UTxOType Payment -> GlobalState
[$sel:finalUTxO:Start] :: GlobalState -> UTxOType Payment
isInitialState :: GlobalState -> Bool
isOpenState :: GlobalState -> Bool
isFinalState :: GlobalState -> Bool
isIdleState :: GlobalState -> Bool
isPendingCommitFrom :: Party -> GlobalState -> Bool
data OffChainState
OffChainState :: UTxOType Payment -> [Payment] -> OffChainState
[$sel:confirmedUTxO:OffChainState] :: OffChainState -> UTxOType Payment
[$sel:seenTransactions:OffChainState] :: OffChainState -> [Payment]
type ActualCommitted = UTxOType Payment
genSeed :: Gen (Action WorldState ())
genContestationPeriod :: Gen ContestationPeriod
genInit :: [(SigningKey HydraKey, b)] -> Gen (Action WorldState ())
genCommit' :: [(SigningKey HydraKey, CardanoSigningKey)] -> (SigningKey HydraKey, CardanoSigningKey) -> Gen (Action WorldState [(CardanoSigningKey, Value)])
genPayment :: WorldState -> Gen (Party, Payment)
unsafeConstructorName :: Show a => a -> String

-- | Generate a list of pairs of Hydra/Cardano signing keys. All the keys
--   in this list are guaranteed to be unique.
partyKeys :: Gen [(SigningKey HydraKey, CardanoSigningKey)]

-- | Concrete state needed to run actions against the implementation. This
--   state is used and might be updated when actually <a>perform</a>ing
--   actions generated from the <a>StateModel</a>.
data Nodes m
Nodes :: Map Party (TestHydraClient Tx m) -> Tracer m (HydraLog Tx ()) -> [Async m ()] -> Nodes m

-- | Map from party identifiers to a <i>handle</i> for interacting with a
--   node.
[$sel:nodes:Nodes] :: Nodes m -> Map Party (TestHydraClient Tx m)

-- | Logger used by each node. The reason we put this here is because the
--   concrete value needs to be instantiated upon the test run
--   initialisation, outiside of the model.
[$sel:logger:Nodes] :: Nodes m -> Tracer m (HydraLog Tx ())

-- | List of threads spawned when executing <a>RunMonad</a>
[$sel:threads:Nodes] :: Nodes m -> [Async m ()]
newtype RunState m
RunState :: TVar m (Nodes m) -> RunState m
[$sel:nodesState:RunState] :: RunState m -> TVar m (Nodes m)

-- | Our execution <a>MonadTrans</a>former.
--   
--   This type is needed in order to keep the execution monad <tt>m</tt>
--   abstract and thus simplify the definition of the <a>RunModel</a>
--   instance which requires a proper definition of <a>Realized</a> type
--   family. See <a>this issue</a> for a discussion on why this monad is
--   needed.
--   
--   We could perhaps getaway with it and just have a type based on
--   <tt>IOSim</tt> monad but this is cumbersome to write.
newtype RunMonad m a
RunMonad :: ReaderT (RunState m) m a -> RunMonad m a
[$sel:runMonad:RunMonad] :: RunMonad m a -> ReaderT (RunState m) m a
data RunException
TransactionNotObserved :: Payment -> UTxO -> RunException
UnexpectedParty :: Party -> RunException
UnknownAddress :: AddressInEra -> [(AddressInEra, CardanoSigningKey)] -> RunException
CannotFindSpendableUTxO :: Payment -> UTxO -> RunException
seedWorld :: (MonadAsync m, MonadTimer m, MonadThrow (STM m), MonadLabelledSTM m, MonadFork m, MonadMask m) => [(SigningKey HydraKey, CardanoSigningKey)] -> ContestationPeriod -> RunMonad m ()
performCommit :: (MonadThrow m, MonadTimer m) => [CardanoSigningKey] -> Party -> [(CardanoSigningKey, Value)] -> RunMonad m ActualCommitted
performNewTx :: (MonadThrow m, MonadAsync m, MonadTimer m) => Party -> Payment -> RunMonad m ()

-- | Wait for the head to be open by searching from the beginning. Note
--   that there rollbacks or multiple life-cycles of heads are not handled
--   here.
waitForOpen :: MonadDelay m => TestHydraClient tx m -> RunMonad m ()
sendsInput :: (MonadSTM m, MonadThrow m) => Party -> ClientInput Tx -> RunMonad m ()
performInit :: (MonadThrow m, MonadAsync m, MonadTimer m) => Party -> RunMonad m ()
performAbort :: (MonadThrow m, MonadAsync m, MonadTimer m) => Party -> RunMonad m ()
stopTheWorld :: MonadAsync m => RunMonad m ()

-- | Bring <a>Show</a> instance in scope drawing it from the <a>Action</a>
--   type.
--   
--   This is a neat trick to provide <a>show</a>able results from action in
--   a context where there's no explicit `Show a` instance, eg. in the
--   <a>monitoring</a> and <a>postcondition</a> functions. We don't have
--   access to an <tt>a</tt> directly because its value depends on type
--   family <a>Realized</a>.
showFromAction :: (Show a => b) -> Action WorldState a -> b
checkOutcome :: WorldState -> Action WorldState a -> a -> Bool
waitForUTxOToSpend :: forall m. MonadTimer m => UTxO -> CardanoSigningKey -> Value -> TestHydraClient Tx m -> m (Either UTxO (TxIn, TxOut CtxUTxO))
isOwned :: CardanoSigningKey -> (TxIn, TxOut ctx) -> Bool
instance GHC.Show.Show Hydra.Model.OffChainState
instance GHC.Classes.Eq Hydra.Model.OffChainState
instance GHC.Show.Show Hydra.Model.GlobalState
instance GHC.Classes.Eq Hydra.Model.GlobalState
instance GHC.Show.Show Hydra.Model.WorldState
instance GHC.Classes.Eq Hydra.Model.WorldState
instance Control.Monad.Class.MonadThrow.MonadThrow m => Control.Monad.Class.MonadThrow.MonadThrow (Hydra.Model.RunMonad m)
instance GHC.Base.Monad m => Control.Monad.Reader.Class.MonadReader (Hydra.Model.RunState m) (Hydra.Model.RunMonad m)
instance GHC.Base.Monad m => GHC.Base.Monad (Hydra.Model.RunMonad m)
instance GHC.Base.Applicative m => GHC.Base.Applicative (Hydra.Model.RunMonad m)
instance GHC.Base.Functor m => GHC.Base.Functor (Hydra.Model.RunMonad m)
instance GHC.Show.Show Hydra.Model.RunException
instance GHC.Classes.Eq Hydra.Model.RunException
instance GHC.Show.Show (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)
instance GHC.Classes.Eq (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)
instance GHC.Exception.Type.Exception Hydra.Model.RunException
instance (Control.Monad.Class.MonadAsync.MonadAsync m, Control.Monad.Class.MonadFork.MonadFork m, Control.Monad.Class.MonadThrow.MonadMask m, Control.Monad.Class.MonadTimer.MonadTimer m, Control.Monad.Class.MonadThrow.MonadThrow (Control.Monad.Class.MonadSTM.Internal.STM m), Control.Monad.Class.MonadSTM.Internal.MonadLabelledSTM m) => Test.QuickCheck.StateModel.RunModel Hydra.Model.WorldState (Hydra.Model.RunMonad m)
instance Control.Monad.Trans.Class.MonadTrans Hydra.Model.RunMonad
instance Control.Monad.Class.MonadSTM.Internal.MonadSTM m => Control.Monad.State.Class.MonadState (Hydra.Model.Nodes m) (Hydra.Model.RunMonad m)
instance Test.QuickCheck.StateModel.StateModel Hydra.Model.WorldState
instance Test.QuickCheck.DynamicLogic.Internal.DynLogicModel Hydra.Model.WorldState
instance Test.QuickCheck.StateModel.Variables.HasVariables Hydra.Model.WorldState
instance Test.QuickCheck.StateModel.Variables.HasVariables (Test.QuickCheck.StateModel.Action Hydra.Model.WorldState a)


-- | Model-Based testing of Hydra Head protocol implementation.
--   
--   <ul>
--   <li>Troubleshooting</li>
--   <li>* Deadlocks</li>
--   </ul>
--   
--   One of the most annoying problems one can face with those very high
--   level properties involving multithreading and a lot of complex moving
--   parts is when the test execution deadlocks. Here is a short guide on
--   what one can do to troubleshoort this kind of issue:
--   
--   <ul>
--   <li>**Check generators**: <tt>suchThat</tt> combinator from QuickCheck
--   is useful when one wants to refine another <a>Gen</a>erator's
--   behaviour but it can lead to deadlock if the filtering leads to no
--   value being generated. Avoid it.</li>
--   <li>**Dump nodes' logs**: In case of a "normal" failure of the tests,
--   the logs from the nodes are dumped. However, if the test does not even
--   complete then no logs are produced because they are kept in memory. In
--   this case. replacing <a>traceInIOSim</a> with `traceInIOSim &lt;&gt;
--   traceDebug` will ensure the logs are dumped on the <a>stderr</a>. It
--   could be a good idea to store them in a file as they can be quite
--   large.</li>
--   <li>**Use** <a>trace</a> liberally: Because getting a proper stack
--   trace is hard in Haskell, esp. in pure code, sprinkling <a>trace</a>
--   statements at key points might help understand what's going on and
--   zoom in on the culprits</li>
--   <li>**Dump IOSim trace**: In case the deadlock (or race condition) is
--   caused by having two or more concurrent threads competing to access a
--   resource, dumping the trace of IOSim's runtime scheduleer execution
--   can help. io-sim generate its trace lazily which means that even when
--   it deadlocks, one can capture at least a significant prefix of the
--   trace and dump it to <a>stderr</a>. One can `map ( t -&gt; trace
--   (ppEvents t) t) . traceEvents` over the <tt>SimTrace</tt> returned by
--   <a>runSimTrace</a> to get some pretty-printed output similar to:</li>
--   </ul>
--   
--   @<tt> Time 380.1s - ThreadId [4] node-94455e3e - EventThrow
--   AsyncCancelled Time 380.1s - ThreadId [4] node-94455e3e - EventMask
--   MaskedInterruptible Time 380.1s - ThreadId [4] node-94455e3e -
--   EventMask MaskedInterruptible Time 380.1s - ThreadId [4] node-94455e3e
--   - EventDeschedule Interruptable Time 380.1s - ThreadId [4]
--   node-94455e3e - EventTxCommitted [Labelled (TVarId 25) (Just
--   "async-ThreadId [4]")] [] Nothing Time 380.1s - ThreadId [] main -
--   EventTxWakeup [Labelled (TVarId 25) (Just "async-ThreadId [4]")] Time
--   380.1s - ThreadId [4] node-94455e3e - EventUnblocked [ThreadId []]
--   Time 380.1s - ThreadId [4] node-94455e3e - EventDeschedule Yield Time
--   380.1s - ThreadId [] main - EventTxCommitted [] [] Nothing Time 380.1s
--   - ThreadId [] main - EventUnblocked [] Time 380.1s - ThreadId [] main
--   - EventDeschedule Yield Time 380.1s - ThreadId [4] node-94455e3e -
--   EventThreadFinished Time 380.1s - ThreadId [4] node-94455e3e -
--   EventDeschedule Terminated Time 380.1s - ThreadId [] main -
--   EventThreadFinished </tt>@
--   
--   <ul>
--   <li>* Recording trace failures</li>
--   </ul>
--   
--   When a property fails it will dump the sequence of actions leading to
--   the failure. This sequence can be copy/pasted and reused directly as a
--   test against either the <tt>Model</tt> or the implementation as
--   exemplified by the following sample:
--   
--   @@ it "runs actions against actual nodes" $ do let Actions act =
--   Actions [ Var 1 := Seed { seedKeys = [ (HydraSigningKey
--   (SignKeyEd25519DSIGN
--   "00000000000000000000000000000000000000000000000000000000000000003b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29"),
--   "0100000008030606080507030707000607020508050000020207070508040800") ,
--   (HydraSigningKey (SignKeyEd25519DSIGN
--   "2e00000000000000000000000000000000000000000000000000000000000000264a0707979e0d6691f74b055429b5f318d39c2883bb509310b67424252e9ef2"),
--   "0106010101070600040403010600080805020003040508030307080706060608") ,
--   (HydraSigningKey (SignKeyEd25519DSIGN
--   "ed785af0fb0000000000000000000000000000000000000000000000000000001c02babf6d3d51b725db8b72043823d66634b39db74836b1494bdb647073d566"),
--   "0000070304040705060101030802010105080806050605070104030603010503") ]
--   } , Var 2 := Command{Model.party = Party{vkey = HydraVerificationKey
--   (VerKeyEd25519DSIGN
--   "3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29")},
--   command = Init{contestationPeriod = -6.413670805613}} , Var 3 :=
--   Command{Model.party = Party{vkey = HydraVerificationKey
--   (VerKeyEd25519DSIGN
--   "264a0707979e0d6691f74b055429b5f318d39c2883bb509310b67424252e9ef2")},
--   command = Commit{Input.utxo =
--   [("0106010101070600040403010600080805020003040508030307080706060608",
--   valueFromList [(AdaAssetId, 18470954)])]}} , Var 4 :=
--   Command{Model.party = Party{vkey = HydraVerificationKey
--   (VerKeyEd25519DSIGN
--   "1c02babf6d3d51b725db8b72043823d66634b39db74836b1494bdb647073d566")},
--   command = Commit{Input.utxo =
--   [("0000070304040705060101030802010105080806050605070104030603010503",
--   valueFromList [(AdaAssetId, 19691416)])]}} , Var 5 :=
--   Command{Model.party = Party{vkey = HydraVerificationKey
--   (VerKeyEd25519DSIGN
--   "3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29")},
--   command = Commit{Input.utxo =
--   [("0100000008030606080507030707000607020508050000020207070508040800",
--   valueFromList [(AdaAssetId, 7003529)])]}} , Var 6 := Command {
--   Model.party = Party{vkey = HydraVerificationKey (VerKeyEd25519DSIGN
--   "3b6a27bcceb6a42d62a3a8d02a6f0d73653215771de243a63ac048a18b59da29")} ,
--   command = NewTx { Input.transaction = Payment { from =
--   "0100000008030606080507030707000607020508050000020207070508040800" ,
--   to =
--   "0106010101070600040403010600080805020003040508030307080706060608" ,
--   value = valueFromList [(AdaAssetId, 7003529)] } } } ] -- env and model
--   state are unused in perform env = []
--   
--   dummyState :: WorldState (IOSim s) dummyState =
--   WorldState{hydraParties = mempty, hydraState = Start}
--   
--   loop [] = pure () loop ((Var{} := a) : as) = do void $ perform
--   dummyState a (lookUpVar env) loop as tr = runSimTrace $ evalStateT
--   (loop act) (Nodes mempty traceInIOSim) traceDump = printTrace (Proxy
--   :: Proxy Tx) tr print traceDump True <a>shouldBe</a> True @@
module Hydra.ModelSpec
spec :: Spec
prop_checkHeadOpensIfAllPartiesCommit :: Property
headOpensIfAllPartiesCommit :: DL WorldState ()
prop_checkConflictFreeLiveness :: Property
prop_HydraModel :: Actions WorldState -> Property
conflictFreeLiveness :: DL WorldState ()
prop_generateTraces :: Actions WorldState -> Property
prop_doesNotGenerate0AdaUTxO :: Actions WorldState -> Bool
prop_checkModel :: Actions WorldState -> Property
assertBalancesInOpenHeadAreConsistent :: GlobalState -> Map Party (TestHydraClient Tx (IOSim s)) -> Party -> PropertyM (RunMonad (IOSim s)) ()

-- | Specialised runner similar to
--   <a>https://hackage.haskell.org/package/QuickCheck-2.14.2/docs/src/Test.QuickCheck.Monadic.html#runSTGen</a>.
runIOSimProp :: Testable a => (forall s. PropertyM (RunMonad (IOSim s)) a) -> Gen Property
unwrapAddress :: AddressInEra -> Text

module Hydra.Logging.MonitoringSpec
spec :: Spec

module Spec
main :: IO ()
spec :: Spec

module Main
main :: IO ()
