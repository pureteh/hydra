-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | TUI for managing a Hydra node
--   
--   TUI for managing a Hydra node
@package hydra-tui
@version 0.11.0

module Hydra.TUI.Options
data Options
Options :: Host -> FilePath -> NetworkId -> FilePath -> Options
[hydraNodeHost] :: Options -> Host
[cardanoNodeSocket] :: Options -> FilePath
[cardanoNetworkId] :: Options -> NetworkId

-- | User key used by the tui client to commit
[cardanoSigningKey] :: Options -> FilePath
parseOptions :: Parser Options
parseCardanoNodeSocket :: Parser FilePath
parseNodeHost :: Parser Host
parseCardanoSigningKey :: Parser FilePath
instance GHC.Show.Show Hydra.TUI.Options.Options
instance GHC.Classes.Eq Hydra.TUI.Options.Options

module Hydra.Client
data HydraEvent tx
ClientConnected :: HydraEvent tx
ClientDisconnected :: HydraEvent tx
Update :: TimedServerOutput tx -> HydraEvent tx
Tick :: UTCTime -> HydraEvent tx

-- | Handle to interact with Hydra node
data Client tx m
Client :: (ClientInput tx -> m ()) -> SigningKey PaymentKey -> (UTxO -> m ()) -> Client tx m

-- | Send some input to the server.
[sendInput] :: Client tx m -> ClientInput tx -> m ()
[sk] :: Client tx m -> SigningKey PaymentKey
[externalCommit] :: Client tx m -> UTxO -> m ()

-- | Callback for receiving server outputs.
type ClientCallback tx m = HydraEvent tx -> m ()

-- | A type tying both receiving output and sending input into a
--   <i>Component</i>.
type ClientComponent tx m a = ClientCallback tx m -> (Client tx m -> m a) -> m a

-- | Provide a component to interact with Hydra node.
withClient :: (ToJSON (ClientInput tx), FromJSON (TimedServerOutput tx)) => Options -> ClientComponent tx IO a
data ClientError
ClientJSONDecodeError :: String -> ByteString -> ClientError
instance GHC.Generics.Generic (Hydra.Client.HydraEvent tx)
instance GHC.Exception.Type.Exception Hydra.Client.ClientError
instance GHC.Generics.Generic Hydra.Client.ClientError
instance GHC.Show.Show Hydra.Client.ClientError
instance GHC.Classes.Eq Hydra.Client.ClientError
instance GHC.Classes.Eq (Hydra.API.ServerOutput.TimedServerOutput tx) => GHC.Classes.Eq (Hydra.Client.HydraEvent tx)
instance GHC.Show.Show (Hydra.API.ServerOutput.TimedServerOutput tx) => GHC.Show.Show (Hydra.Client.HydraEvent tx)

module Hydra.TUI
data FeedbackState
Short :: FeedbackState
Full :: FeedbackState
data State
Disconnected :: Host -> UTCTime -> State
[$sel:nodeHost:Disconnected] :: State -> Host
[$sel:now:Disconnected] :: State -> UTCTime
Connected :: Maybe Party -> Host -> [NodeId] -> HeadState -> DialogState -> FeedbackState -> [UserFeedback] -> UTCTime -> Pending -> Maybe HeadId -> State
[$sel:me:Disconnected] :: State -> Maybe Party
[$sel:nodeHost:Disconnected] :: State -> Host
[$sel:peers:Disconnected] :: State -> [NodeId]
[$sel:headState:Disconnected] :: State -> HeadState
[$sel:dialogState:Disconnected] :: State -> DialogState
[$sel:feedbackState:Disconnected] :: State -> FeedbackState
[$sel:feedback:Disconnected] :: State -> [UserFeedback]
[$sel:now:Disconnected] :: State -> UTCTime
[$sel:pending:Disconnected] :: State -> Pending
[$sel:hydraHeadId:Disconnected] :: State -> Maybe HeadId
data Pending
Pending :: Pending
NotPending :: Pending
data UserFeedback
UserFeedback :: Severity -> Text -> UTCTime -> UserFeedback
[$sel:severity:UserFeedback] :: UserFeedback -> Severity
[$sel:message:UserFeedback] :: UserFeedback -> Text
[$sel:time:UserFeedback] :: UserFeedback -> UTCTime
data Severity
Success :: Severity
Info :: Severity
Error :: Severity
data DialogState
[NoDialog] :: DialogState
[Dialog] :: forall s e n. (n ~ Name, e ~ HydraEvent Tx) => Text -> Form s e n -> (State -> s -> EventM n (Next State)) -> DialogState
data HeadState
Idle :: HeadState
Initializing :: [Party] -> [Party] -> UTxO -> HeadId -> HeadState
[$sel:parties:Idle] :: HeadState -> [Party]
[$sel:remainingParties:Idle] :: HeadState -> [Party]
[$sel:utxo:Idle] :: HeadState -> UTxO
[$sel:headId:Idle] :: HeadState -> HeadId
Open :: [Party] -> UTxO -> HeadId -> HeadState
[$sel:parties:Idle] :: HeadState -> [Party]
[$sel:utxo:Idle] :: HeadState -> UTxO
[$sel:headId:Idle] :: HeadState -> HeadId
Closed :: UTCTime -> HeadId -> HeadState
[$sel:contestationDeadline:Idle] :: HeadState -> UTCTime
[$sel:headId:Idle] :: HeadState -> HeadId
FanoutPossible :: HeadId -> HeadState
[$sel:headId:Idle] :: HeadState -> HeadId
Final :: UTxO -> HeadState
[$sel:utxo:Idle] :: HeadState -> UTxO
type Name = Text
pendingL :: Traversal' State Pending
peersL :: Traversal' State [NodeId]
nowL :: Lens' State UTCTime
nodeHostL :: Lens' State Host
meL :: Traversal' State (Maybe Party)
hydraHeadIdL :: Traversal' State (Maybe HeadId)
headStateL :: Traversal' State HeadState
feedbackStateL :: Traversal' State FeedbackState
feedbackL :: Traversal' State [UserFeedback]
dialogStateL :: Traversal' State DialogState
utxoL :: Traversal' HeadState UTxO
remainingPartiesL :: Traversal' HeadState [Party]
partiesL :: Traversal' HeadState [Party]
headIdL :: Traversal' HeadState HeadId
severityToAttr :: Severity -> AttrName
infoA :: AttrName
positive :: AttrName
negative :: AttrName
own :: AttrName
info :: Text -> State -> State
info' :: UTCTime -> Text -> State -> State
warn :: Text -> State -> State
warn' :: UTCTime -> Text -> State -> State
report :: Severity -> Text -> State -> State
report' :: UTCTime -> Severity -> Text -> State -> State
stopPending :: State -> State
initPending :: State -> State
handleEvent :: Client Tx IO -> CardanoClient -> State -> BrickEvent Name (HydraEvent Tx) -> EventM Name (Next State)
setPending :: State -> EventM n (Next State)
handleAppEvent :: State -> HydraEvent Tx -> State
handleDialogEvent :: forall s e n. (n ~ Name, e ~ HydraEvent Tx) => (Text, Form s e n, State -> s -> EventM n (Next State)) -> State -> Event -> EventM n (Next State)
showCommitDialog :: Client Tx IO -> CardanoClient -> State -> EventM n (Next State)
handleNewTxEvent :: Client Tx IO -> CardanoClient -> State -> EventM n (Next State)
fullFeedbackViewportName :: Name
shortFeedbackViewportName :: Name
scroll :: State -> Direction -> EventM Name ()
draw :: Client Tx m -> CardanoClient -> State -> [Widget Name]
renderTime :: (Ord t, Num t, FormatTime t) => t -> String
utxoCheckboxField :: forall s e n. (s ~ Map TxIn (TxOut CtxUTxO, Bool), n ~ Name) => Map TxIn (TxOut CtxUTxO) -> [s -> FormFieldState s e n]
utxoRadioField :: forall s e n. (s ~ (TxIn, TxOut CtxUTxO), n ~ Name) => Map TxIn (TxOut CtxUTxO) -> [s -> FormFieldState s e n]
myAvailableUTxO :: NetworkId -> VerificationKey PaymentKey -> State -> Map TxIn (TxOut CtxUTxO)
style :: State -> AttrMap
runWithVty :: IO Vty -> Options -> IO State
run :: Options -> IO State
instance GHC.Generics.Generic Hydra.TUI.Pending
instance GHC.Show.Show Hydra.TUI.Pending
instance GHC.Classes.Eq Hydra.TUI.Pending
instance GHC.Generics.Generic Hydra.TUI.Severity
instance GHC.Show.Show Hydra.TUI.Severity
instance GHC.Classes.Eq Hydra.TUI.Severity
instance GHC.Generics.Generic Hydra.TUI.UserFeedback
instance GHC.Show.Show Hydra.TUI.UserFeedback
instance GHC.Classes.Eq Hydra.TUI.UserFeedback
instance GHC.Generics.Generic Hydra.TUI.HeadState
instance GHC.Show.Show Hydra.TUI.HeadState
instance GHC.Classes.Eq Hydra.TUI.HeadState
