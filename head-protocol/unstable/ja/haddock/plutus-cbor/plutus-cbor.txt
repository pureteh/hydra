-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | On-chain CBOR encoders/decoders
--   
--   On-chain CBOR encoders/decoders
@package plutus-cbor
@version 1.0.1


-- | An on-chain implementation of <a>RFC 8949</a>: Concise Binary Object
--   Representation (CBOR).
--   
--   This is generally something one would want to avoid as the memory and
--   CPU budgets on-chain are heavily limited. However, there are scenarios
--   when one needs to serialise some higher level data-type into binary.
--   This library provides an efficient way of doing it.
--   
--   <h1>How to use</h1>
--   
--   Let's start with some relatively simple type:
--   
--   <pre>
--   data Foo = Foo
--    { bar :: Bool
--    , baz :: Integer
--    }
--   </pre>
--   
--   From there, one can define an <a>Encoding</a> for the <tt>Foo</tt>
--   data-type. This is a simple record of unary constructors, so using a
--   2-tuple should do. Note that <a>Encoding</a> is a <a>Semigroup</a>,
--   and thus, they are easily composed using the concatenation operator
--   (<a>&lt;&gt;</a>).
--   
--   <pre>
--   encodeFoo :: Foo -&gt; Encoding
--   encodeFoo Foo{bar,baz} =
--     encodeListLen 2
--       &lt;&gt; encodeBool bar
--       &lt;&gt; encodeInteger baz
--   </pre>
--   
--   Then, any <a>Encoding</a> can be turned into a
--   <a>BuiltinByteString</a> using: <a>encodingToBuiltinByteString</a>.
--   For instance, one could define:
--   
--   <pre>
--   serialiseFoo :: Foo -&gt; BuiltinByteString
--   serialiseFoo = encodingToBuiltinByteString . encodeFoo
--   </pre>
module Plutus.Codec.CBOR.Encoding

-- | An opaque <a>Encoding</a> type. See also
--   <a>encodingToBuiltinByteString</a>.
data Encoding

-- | Runs an encoder and produce a <a>BuiltinByteString</a>.
encodingToBuiltinByteString :: Encoding -> BuiltinByteString

-- | Encode a <a>Bool</a> as a CBOR type-07 major type.
encodeBool :: Bool -> Encoding

-- | Encode an <a>Integer</a> as a CBOR type-00 or type-01 (negative)
--   number.
--   
--   Note (1): The <a>Encoding</a> is of variable-length, larger numbers
--   are larger to encode.
--   
--   Note (2): This can only encode numbers up to <tt>2^64 - 1</tt> and
--   down to <tt>-2^63</tt>
encodeInteger :: Integer -> Encoding

-- | Encode a <a>BuiltinByteString</a> as a CBOR type-02 major type.
encodeByteString :: BuiltinByteString -> Encoding

-- | Encode a <a>BuiltinString</a> as a CBOR type-03 major type.
encodeString :: BuiltinString -> Encoding

-- | Encode a null character, useful to encode optional values.
encodeNull :: Encoding

-- | Helper for optionally encoding a type. Note that in the
--   <tt>Nothing</tt> case, this is a no-op.
encodeMaybe :: (a -> Encoding) -> Maybe a -> Encoding

-- | Declare a list of fixed size. Each element of the list must then be
--   separately provided via appending them (<a>Encoding</a> is a
--   <a>Semigroup</a>).
--   
--   This is useful to construct non-uniform arrays where elements may have
--   different types. For uniform list, see <a>encodeList</a>.
--   
--   <pre>
--   -- Encoding (14, 42) as a finite list...
--   encodeListLen 2
--     &lt;&gt; encodeInteger 14
--     &lt;&gt; encodeInteger 42
--   </pre>
encodeListLen :: Integer -> Encoding

-- | Shorthand for encoding a uniform list. Note that CBOR supports
--   non-uniform lists (i.e. n-tuples) for which one should use
--   <a>encodeListLen</a> or <a>encodeBeginList</a> / <a>encodeBreak</a>.
encodeList :: (a -> Encoding) -> [a] -> Encoding

-- | Declare a map of fixed size. Each key/value pair of the map must then
--   be separately provided via appending them (<a>Encoding</a> is a
--   <a>Semigroup</a>).
--   
--   This is useful to construct non-uniform maps where keys and values may
--   have different types. For uniform maps, see <a>encodeMap</a>.
--   
--   <pre>
--   -- Encoding { 14: b'1abc', 42: b'0000' } as a finite map...
--   encodeMapLen 2
--     &lt;&gt; encodeInteger 14 &lt;&gt; encodeByteString "1abc"
--     &lt;&gt; encodeInteger 42 &lt;&gt; encodeByteString "0000"
--   </pre>
encodeMapLen :: Integer -> Encoding

-- | Shorthand for encoding a uniform map of fixed size.
--   
--   see also: <a>encodeMapLen</a> / <a>encodeBreak</a> for non-uniform
--   maps.
encodeMap :: (k -> Encoding) -> (v -> Encoding) -> Map k v -> Encoding

-- | Encode a indefinite list or map termination. This must come (not
--   necessarily immediately) after an <a>encodeListIndef</a> or
--   <a>encodeMapIndef</a>
encodeBreak :: Encoding

-- | Declare a list of indefinite size. Each element of the list must then
--   be separately provided via appending them (<a>Encoding</a> is a
--   <a>Semigroup</a>).
--   
--   This is useful to construct non-uniform arrays where elements may have
--   different types. For uniform list, see <a>encodeListIndef</a>.
--   
--   <pre>
--   -- Encoding (14, 42) as an indefinite list...
--   encodeBeginList
--     &lt;&gt; encodeInteger 14
--     &lt;&gt; encodeInteger 42
--     &lt;&gt; encodeBreak
--   </pre>
encodeBeginList :: Encoding

-- | Shorthand for encoding uniform list of indefinite sizes. Note that
--   CBOR supports non-uniform indefinite list (i.e. n-tuples) for which
--   one should use <a>encodeListLen</a> or <a>encodeBeginList</a> /
--   <a>encodeBreak</a>.
encodeListIndef :: (a -> Encoding) -> [a] -> Encoding

-- | Declare a map of indefinite size. Each key/value pair of the map must
--   then be separately provided via appending them (<a>Encoding</a> is a
--   <a>Semigroup</a>).
--   
--   This is useful to construct non-uniform maps where keys and values may
--   have different types. For uniform maps, see <a>encodeMap</a>.
--   
--   <pre>
--   -- Encoding { 14: b'1abc', 42: b'0000' } as a finite map...
--   encodeBeginMap
--     &lt;&gt; encodeInteger 14 &lt;&gt; encodeByteString "1abc"
--     &lt;&gt; encodeInteger 42 &lt;&gt; encodeByteString "0000"
--     &lt;&gt; encodeBreak
--   </pre>
encodeBeginMap :: Encoding

-- | Shorthand for encoding a uniform map of indefinite size.
--   
--   see also: <a>encodeBeginMap</a> / <a>encodeBreak</a> for non-uniform
--   maps.
encodeMapIndef :: (k -> Encoding) -> (v -> Encoding) -> Map k v -> Encoding

-- | Encode a CBOR-tag as a major type-06.
--   
--   Well known tags:
--   
--   TODO: table
--   
--   For more tags, have a look at <a>iana's Concise Binary Object
--   Representation (CBOR) Tags list</a>.
encodeTag :: Integer -> Encoding

-- | Inject an already CBOR-encoded bytestring into an <a>Encoding</a>. Do
--   not use unless you know what you're doing, this may creates an
--   <a>Encoding</a> not compliant with the CBOR specification.
unsafeEncodeRaw :: BuiltinByteString -> Encoding
instance PlutusTx.Semigroup.Semigroup Plutus.Codec.CBOR.Encoding.Encoding
instance PlutusTx.Monoid.Monoid Plutus.Codec.CBOR.Encoding.Encoding
