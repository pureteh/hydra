-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Integration test suite using a local cluster of cardano and hydra nodes
--   
--   Integration test suite using a local cluster of cardano and hydra
--   nodes
@package hydra-cluster
@version 0.11.0


-- | Example values and utilities used across hydra-cluster tests and
--   benchmarks.
module Hydra.Cluster.Fixture
alice :: Party
bob :: Party
carol :: Party
aliceSk :: SigningKey HydraKey
bobSk :: SigningKey HydraKey
carolSk :: SigningKey HydraKey
aliceVk :: VerificationKey HydraKey
bobVk :: VerificationKey HydraKey
carolVk :: VerificationKey HydraKey
cperiod :: ContestationPeriod

-- | TODO: This is hard-coded and must match what's in the genesis file, so
--   ideally, we want to either:
--   
--   <ul>
--   <li>overwrite the genesis configuration with the
--   <tt>ClusterConfig</tt></li>
--   <li>pull the network id from the genesis configuration</li>
--   </ul>
defaultNetworkId :: NetworkId
availableInitialFunds :: Num a => a

-- | Enumeration of known actors for which we can get the <tt>keysFor</tt>
--   and <tt>writeKeysFor</tt>.
data Actor
Alice :: Actor
Bob :: Actor
Carol :: Actor
Faucet :: Actor
actorName :: Actor -> String

-- | A network known to the hydra-cluster. That means we have configuration
--   files to connect to at least these networks.
data KnownNetwork
Preview :: KnownNetwork
Preproduction :: KnownNetwork
Mainnet :: KnownNetwork
instance GHC.Show.Show Hydra.Cluster.Fixture.Actor
instance GHC.Classes.Eq Hydra.Cluster.Fixture.Actor
instance GHC.Show.Show Hydra.Cluster.Fixture.KnownNetwork

module Hydra.Cluster.Options
data Options
Options :: Maybe KnownNetwork -> Maybe FilePath -> PublishOrReuse -> Options
[knownNetwork] :: Options -> Maybe KnownNetwork
[stateDirectory] :: Options -> Maybe FilePath
[publishHydraScripts] :: Options -> PublishOrReuse
data PublishOrReuse
Publish :: PublishOrReuse
Reuse :: TxId -> PublishOrReuse
parseOptions :: Parser Options
instance GHC.Show.Show Hydra.Cluster.Options.PublishOrReuse
instance GHC.Show.Show Hydra.Cluster.Options.Options


-- | Utility functions to filter and simplify raw logs.
module Hydra.LogFilter

-- | A trace of an event or effect for a specific transaction.
data Trace tx
TraceEvent :: UTCTime -> TxIdType tx -> NominalDiffTime -> Text -> Trace tx

-- | The starting point in time for this event.
[$sel:timestamp:TraceEvent] :: Trace tx -> UTCTime

-- | The transaction id this event applies to.
[$sel:txid:TraceEvent] :: Trace tx -> TxIdType tx

-- | The duration of the event, expressed as a number of seconds with a
--   $10^12$ precision.
[$sel:us:TraceEvent] :: Trace tx -> NominalDiffTime

-- | A string identifying this event.
[$sel:event:TraceEvent] :: Trace tx -> Text
TraceEffect :: UTCTime -> TxIdType tx -> NominalDiffTime -> Text -> Trace tx

-- | The starting point in time for this event.
[$sel:timestamp:TraceEvent] :: Trace tx -> UTCTime

-- | The transaction id this event applies to.
[$sel:txid:TraceEvent] :: Trace tx -> TxIdType tx

-- | The duration of the event, expressed as a number of seconds with a
--   $10^12$ precision.
[$sel:us:TraceEvent] :: Trace tx -> NominalDiffTime

-- | A string identifying this effect.
[$sel:effect:TraceEvent] :: Trace tx -> Text
data TraceKey
EventKey :: Word64 -> TraceKey
EffectKey :: Word64 -> Word32 -> TraceKey

-- | Compute duration of some <a>Event</a>s and <a>Effect</a>s from logs.
--   
--   This function is meant to be used with a <a>sequence</a> in order to
--   traverse a stream of log entries and output list of <a>Trace</a> as
--   begin/end pairs are found and identified. Each <a>Trace</a> emitted is
--   tied to a specific transaction id which provides an easy way to
--   identify in which part of their journey through Hydra transactions are
--   spending time.
--   
--   It currently compute duration of: * <a>NewTx</a>, <a>ReqTx</a>,
--   <a>ReqSn</a> events, * <a>ReqTx</a>, <a>TxValid</a> and
--   <a>SnapshotConfirmed</a> effects.
--   
--   NOTE: Some potential improvements * Move this function to
--   <tt>Monitoring</tt> and expose an histogram kind of metric for each
--   type of event / effect * Handle more events, in particular the
--   <a>AckSn</a> which is slightly problematic as it does not contain a
--   direct reference to a transaction id so we would need to carry around
--   a secondary map to keep track of this link.
tracePerformance :: IsTx tx => Envelope (HydraLog tx (Message tx)) -> State (Map TraceKey [Trace tx]) [Trace tx]
instance GHC.Generics.Generic (Hydra.LogFilter.Trace tx)
instance GHC.Classes.Ord Hydra.LogFilter.TraceKey
instance GHC.Show.Show Hydra.LogFilter.TraceKey
instance GHC.Classes.Eq Hydra.LogFilter.TraceKey
instance Hydra.Ledger.IsTx tx => GHC.Classes.Eq (Hydra.LogFilter.Trace tx)
instance Hydra.Ledger.IsTx tx => GHC.Show.Show (Hydra.LogFilter.Trace tx)
instance Hydra.Ledger.IsTx tx => Data.Aeson.Types.ToJSON.ToJSON (Hydra.LogFilter.Trace tx)

module Paths_hydra_cluster
version :: Version
getBinDir :: IO FilePath
getLibDir :: IO FilePath
getDynLibDir :: IO FilePath
getDataDir :: IO FilePath
getLibexecDir :: IO FilePath
getDataFileName :: FilePath -> IO FilePath
getSysconfDir :: IO FilePath


-- | Utilities used across hydra-cluster
module Hydra.Cluster.Util

-- | Lookup a config file similar reading a file from disk. If the env
--   variable <tt>HYDRA_CONFIG_DIR</tt> is set, filenames will be resolved
--   relative to its value otherwise they will be looked up in the
--   package's data path.
readConfigFile :: FilePath -> IO ByteString

-- | Get the "well-known" keys for given actor.
keysFor :: Actor -> IO (VerificationKey PaymentKey, SigningKey PaymentKey)

-- | Create and save new signing key at the provided path. NOTE: Uses
--   <tt>TextEnvelope</tt> format.
createAndSaveSigningKey :: FilePath -> IO (SigningKey PaymentKey)
chainConfigFor :: HasCallStack => Actor -> FilePath -> FilePath -> [Actor] -> ContestationPeriod -> IO ChainConfig

module CardanoNode
type Port = Int
newtype NodeId
NodeId :: Int -> NodeId
data RunningNode
RunningNode :: FilePath -> NetworkId -> RunningNode
[$sel:nodeSocket:RunningNode] :: RunningNode -> FilePath
[$sel:networkId:RunningNode] :: RunningNode -> NetworkId

-- | Configuration parameters for a single node devnet
data DevnetConfig
DevnetConfig :: FilePath -> UTCTime -> PortsConfig -> DevnetConfig

-- | Parent state directory
[$sel:stateDirectory:DevnetConfig] :: DevnetConfig -> FilePath

-- | Blockchain start time
[$sel:systemStart:DevnetConfig] :: DevnetConfig -> UTCTime

-- | A list of port
[$sel:ports:DevnetConfig] :: DevnetConfig -> PortsConfig

-- | Arguments given to the 'cardano-node' command-line to run a node.
data CardanoNodeArgs
CardanoNodeArgs :: FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe FilePath -> Maybe Port -> CardanoNodeArgs
[$sel:nodeSocket:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeConfigFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeByronGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeShelleyGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeAlonzoGenesisFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeTopologyFile:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeDatabaseDir:CardanoNodeArgs] :: CardanoNodeArgs -> FilePath
[$sel:nodeDlgCertFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeSignKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeOpCertFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeKesKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodeVrfKeyFile:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe FilePath
[$sel:nodePort:CardanoNodeArgs] :: CardanoNodeArgs -> Maybe Port
defaultCardanoNodeArgs :: CardanoNodeArgs

-- | Configuration of ports from the perspective of a peer in the context
--   of a fully sockected topology.
data PortsConfig
PortsConfig :: Port -> [Port] -> PortsConfig

-- | Our node TCP port.
[$sel:ours:PortsConfig] :: PortsConfig -> Port

-- | Other peers TCP ports.
[$sel:peers:PortsConfig] :: PortsConfig -> [Port]
getCardanoNodeVersion :: IO String

-- | Start a single cardano-node devnet using the config from config/ and
--   credentials from config<i>credentials</i>. Only the <tt>Faucet</tt>
--   actor will receive "initialFunds". Use <tt>seedFromFaucet</tt> to
--   distribute funds other wallets.
withCardanoNodeDevnet :: Tracer IO NodeLog -> FilePath -> (RunningNode -> IO a) -> IO a

-- | Run a cardano-node as normal network participant on a known network.
withCardanoNodeOnKnownNetwork :: Tracer IO NodeLog -> FilePath -> KnownNetwork -> (RunningNode -> IO ()) -> IO ()
withCardanoNode :: Tracer IO NodeLog -> NetworkId -> FilePath -> CardanoNodeArgs -> (RunningNode -> IO a) -> IO a

-- | Wait for the node socket file to become available.
waitForSocket :: RunningNode -> IO ()

-- | Generate command-line arguments for launching <tt>cardano-node</tt>.
cardanoNodeProcess :: Maybe FilePath -> CardanoNodeArgs -> CreateProcess

-- | Initialize the system start time to now (modulo a small offset needed
--   to give time to the system to bootstrap correctly).
initSystemStart :: IO UTCTime

-- | Re-generate configuration and genesis files with fresh system start
--   times.
refreshSystemStart :: FilePath -> CardanoNodeArgs -> IO ()

-- | Generate a topology file from a list of peers.
mkTopology :: [Port] -> Value
generateCardanoKey :: IO (VerificationKey PaymentKey, SigningKey PaymentKey)
data ProcessHasExited
ProcessHasExited :: Text -> ExitCode -> ProcessHasExited
data NodeLog
MsgNodeCmdSpec :: Text -> NodeLog
MsgCLI :: [Text] -> NodeLog
MsgCLIStatus :: Text -> Text -> NodeLog
MsgCLIRetry :: Text -> NodeLog
MsgCLIRetryResult :: Text -> Int -> NodeLog
MsgNodeStarting :: FilePath -> NodeLog
[$sel:stateDirectory:MsgNodeCmdSpec] :: NodeLog -> FilePath
MsgSocketIsReady :: FilePath -> NodeLog
MsgSynchronizing :: Centi -> NodeLog
[$sel:percentDone:MsgNodeCmdSpec] :: NodeLog -> Centi
MsgNodeIsReady :: NodeLog
addField :: ToJSON a => Key -> a -> Value -> Value

-- | Do something with an a JSON object. Fails if the given JSON value
--   isn't an object.
withObject :: (Object -> Object) -> Value -> Value
unsafeDecodeJson :: FromJSON a => ByteString -> IO a
unsafeDecodeJsonFile :: FromJSON a => FilePath -> IO a
instance Data.Aeson.Types.FromJSON.FromJSON CardanoNode.NodeId
instance Data.Aeson.Types.ToJSON.ToJSON CardanoNode.NodeId
instance GHC.Num.Num CardanoNode.NodeId
instance GHC.Show.Show CardanoNode.NodeId
instance GHC.Classes.Eq CardanoNode.NodeId
instance Data.Aeson.Types.FromJSON.FromJSON CardanoNode.PortsConfig
instance Data.Aeson.Types.ToJSON.ToJSON CardanoNode.PortsConfig
instance GHC.Generics.Generic CardanoNode.PortsConfig
instance GHC.Classes.Eq CardanoNode.PortsConfig
instance GHC.Show.Show CardanoNode.PortsConfig
instance Data.Aeson.Types.FromJSON.FromJSON CardanoNode.DevnetConfig
instance Data.Aeson.Types.ToJSON.ToJSON CardanoNode.DevnetConfig
instance GHC.Generics.Generic CardanoNode.DevnetConfig
instance GHC.Show.Show CardanoNode.DevnetConfig
instance GHC.Classes.Eq CardanoNode.DevnetConfig
instance GHC.Show.Show CardanoNode.ProcessHasExited
instance Data.Aeson.Types.FromJSON.FromJSON CardanoNode.NodeLog
instance Data.Aeson.Types.ToJSON.ToJSON CardanoNode.NodeLog
instance GHC.Generics.Generic CardanoNode.NodeLog
instance GHC.Show.Show CardanoNode.NodeLog
instance GHC.Classes.Eq CardanoNode.NodeLog
instance GHC.Exception.Type.Exception CardanoNode.ProcessHasExited


-- | A cardano-node client used in end-to-end tests and benchmarks.
--   
--   This modules contains some more functions besides the re-exported
--   basic querying of hydra-node's <a>CardanoClient</a>.
module CardanoClient
instance GHC.Show.Show CardanoClient.Sizes
instance GHC.Classes.Eq CardanoClient.Sizes

module Hydra.Generator
networkId :: NetworkId

-- | A <a>Dataset</a> that can be run for testing purpose. The
--   <tt>transactionSequence</tt> is guaranteed to be applicable, in
--   sequence, to the <a>initialUTxO</a> set.
data Dataset
Dataset :: Tx -> [ClientDataset] -> Dataset
[fundingTransaction] :: Dataset -> Tx
[clientDatasets] :: Dataset -> [ClientDataset]
data ClientKeys
ClientKeys :: SigningKey PaymentKey -> SigningKey PaymentKey -> ClientKeys

-- | Key used by the hydra-node to authorize hydra transactions and holding
--   fuel.
[signingKey] :: ClientKeys -> SigningKey PaymentKey

-- | Key holding funds to commit.
[externalSigningKey] :: ClientKeys -> SigningKey PaymentKey
data ClientDataset
ClientDataset :: ClientKeys -> UTxO -> [Tx] -> ClientDataset
[clientKeys] :: ClientDataset -> ClientKeys
[initialUTxO] :: ClientDataset -> UTxO
[txSequence] :: ClientDataset -> [Tx]
defaultProtocolParameters :: ProtocolParameters

-- | Generate <a>Dataset</a> which does not grow the per-client UTXO set
--   over time. The sequence of transactions generated consist only of
--   simple payments from and to arbitrary keys controlled by the
--   individual clients.
generateConstantUTxODataset :: ProtocolParameters -> Int -> Int -> IO Dataset
genDatasetConstantUTxO :: SigningKey PaymentKey -> ProtocolParameters -> Int -> Int -> Gen Dataset
instance GHC.Show.Show Hydra.Generator.ClientKeys
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Generator.ClientDataset
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Generator.ClientDataset
instance GHC.Generics.Generic Hydra.Generator.ClientDataset
instance GHC.Show.Show Hydra.Generator.ClientDataset
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Generator.Dataset
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Generator.Dataset
instance GHC.Generics.Generic Hydra.Generator.Dataset
instance GHC.Show.Show Hydra.Generator.Dataset
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Generator.Dataset
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Generator.ClientKeys
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Generator.ClientKeys
instance Test.QuickCheck.Arbitrary.Arbitrary Hydra.Generator.ClientKeys

module Hydra.Cluster.Faucet
data Marked
Fuel :: Marked
Normal :: Marked
data FaucetException
FaucetHasNotEnoughFunds :: UTxO -> FaucetException
[faucetUTxO] :: FaucetException -> UTxO
FaucetFailedToBuildTx :: TxBodyErrorAutoBalance -> FaucetException
[reason] :: FaucetException -> TxBodyErrorAutoBalance
data FaucetLog
TraceResourceExhaustedHandled :: Text -> FaucetLog
ReturnedFunds :: String -> Lovelace -> FaucetLog
[actor] :: FaucetLog -> String
[returnAmount] :: FaucetLog -> Lovelace

-- | Create a specially marked "seed" UTXO containing requested
--   <a>Lovelace</a> by redeeming funds available to the well-known faucet.
seedFromFaucet :: RunningNode -> VerificationKey PaymentKey -> Lovelace -> Marked -> Tracer IO FaucetLog -> IO UTxO
findFaucetUTxO :: RunningNode -> Lovelace -> IO UTxO

-- | Like <a>seedFromFaucet</a>, but without returning the seeded
--   <a>UTxO</a>.
seedFromFaucet_ :: RunningNode -> VerificationKey PaymentKey -> Lovelace -> Marked -> Tracer IO FaucetLog -> IO ()

-- | Return the remaining funds to the faucet
returnFundsToFaucet :: Tracer IO FaucetLog -> RunningNode -> Actor -> IO ()
createOutputAtAddress :: ToScriptData a => RunningNode -> ProtocolParameters -> AddressInEra -> a -> IO (TxIn, TxOut CtxUTxO)

-- | Build and sign tx and return the calculated fee. - Signing key should
--   be the key of a sender - Address is used as a change address.
calculateTxFee :: RunningNode -> SigningKey PaymentKey -> UTxO -> AddressInEra -> Lovelace -> IO Lovelace

-- | Try to submit tx and retry when some caught exception/s take place.
retryOnExceptions :: (MonadCatch m, MonadDelay m) => Tracer m FaucetLog -> m () -> m ()

-- | Publish current Hydra scripts as scripts outputs for later referencing
--   them.
--   
--   The key of the given Actor is used to pay for fees in required
--   transactions, it is expected to have sufficient funds.
publishHydraScriptsAs :: RunningNode -> Actor -> IO TxId

-- | Like <a>queryUTxOFor</a> at the tip, but also partition outputs marked
--   as <a>Fuel</a> and <a>Normal</a>.
--   
--   Throws at least <tt>QueryException</tt> if query fails.
queryMarkedUTxO :: RunningNode -> VerificationKey PaymentKey -> IO (UTxO, UTxO)
instance GHC.Show.Show Hydra.Cluster.Faucet.FaucetException
instance Data.Aeson.Types.FromJSON.FromJSON Hydra.Cluster.Faucet.FaucetLog
instance Data.Aeson.Types.ToJSON.ToJSON Hydra.Cluster.Faucet.FaucetLog
instance GHC.Generics.Generic Hydra.Cluster.Faucet.FaucetLog
instance GHC.Show.Show Hydra.Cluster.Faucet.FaucetLog
instance GHC.Classes.Eq Hydra.Cluster.Faucet.FaucetLog
instance GHC.Exception.Type.Exception Hydra.Cluster.Faucet.FaucetException

module HydraNode
data HydraClient
HydraClient :: Int -> Connection -> Tracer IO EndToEndLog -> HydraClient
[$sel:hydraNodeId:HydraClient] :: HydraClient -> Int
[$sel:connection:HydraClient] :: HydraClient -> Connection
[$sel:tracer:HydraClient] :: HydraClient -> Tracer IO EndToEndLog

-- | Create an input as expected by <a>send</a>.
input :: Text -> [Pair] -> Value
send :: HydraClient -> Value -> IO ()
waitNext :: HasCallStack => HydraClient -> IO Value

-- | Create an output as expected by <a>waitFor</a> and <a>waitForAll</a>.
output :: Text -> [Pair] -> Value

-- | Wait some time for a single API server output from each of given
--   nodes. This function waits for <tt>delay</tt> seconds for message
--   <tt>expected</tt> to be seen by all given <tt>nodes</tt>.
waitFor :: HasCallStack => Tracer IO EndToEndLog -> NominalDiffTime -> [HydraClient] -> Value -> IO ()

-- | Wait up to some time for an API server output to match the given
--   predicate.
waitMatch :: HasCallStack => NominalDiffTime -> HydraClient -> (Value -> Maybe a) -> IO a

-- | Wait up to some <tt>delay</tt> for some JSON <a>Value</a> to match
--   given function.
--   
--   This is a generalisation of <a>waitMatch</a> to multiple nodes.
waitForAllMatch :: (Eq a, Show a, HasCallStack) => NominalDiffTime -> [HydraClient] -> (Value -> Maybe a) -> IO a

-- | Wait some time for a list of outputs from each of given nodes. This
--   function is the generalised version of <a>waitFor</a>, allowing
--   several messages to be waited for and received in <i>any order</i>.
waitForAll :: HasCallStack => Tracer IO EndToEndLog -> NominalDiffTime -> [HydraClient] -> [Value] -> IO ()

-- | Create a commit tx using the hydra-node for later submission
externalCommit' :: HydraClient -> UTxO' TxOutWithWitness -> IO Tx

-- | Helper to make it easy to externally commit non-script utxo
externalCommit :: HydraClient -> UTxO -> IO Tx
getMetrics :: HasCallStack => HydraClient -> IO ByteString
data EndToEndLog
NodeStarted :: Int -> EndToEndLog
[$sel:nodeId:NodeStarted] :: EndToEndLog -> Int
SentMessage :: Int -> Value -> EndToEndLog
[$sel:nodeId:NodeStarted] :: EndToEndLog -> Int
[$sel:message:NodeStarted] :: EndToEndLog -> Value
StartWaiting :: [Int] -> [Value] -> EndToEndLog
[$sel:nodeIds:NodeStarted] :: EndToEndLog -> [Int]
[$sel:messages:NodeStarted] :: EndToEndLog -> [Value]
ReceivedMessage :: Int -> Value -> EndToEndLog
[$sel:nodeId:NodeStarted] :: EndToEndLog -> Int
[$sel:message:NodeStarted] :: EndToEndLog -> Value
EndWaiting :: Int -> EndToEndLog
[$sel:nodeId:NodeStarted] :: EndToEndLog -> Int
FromCardanoNode :: NodeLog -> EndToEndLog
FromFaucet :: FaucetLog -> EndToEndLog
StartingFunds :: String -> UTxO -> UTxO -> EndToEndLog
[$sel:actor:NodeStarted] :: EndToEndLog -> String
[$sel:fuelUTxO:NodeStarted] :: EndToEndLog -> UTxO
[$sel:otherUTxO:NodeStarted] :: EndToEndLog -> UTxO
RefueledFunds :: String -> Lovelace -> UTxO -> EndToEndLog
[$sel:actor:NodeStarted] :: EndToEndLog -> String
[$sel:refuelingAmount:NodeStarted] :: EndToEndLog -> Lovelace
[$sel:fuelUTxO:NodeStarted] :: EndToEndLog -> UTxO
RemainingFunds :: String -> UTxO -> UTxO -> EndToEndLog
[$sel:actor:NodeStarted] :: EndToEndLog -> String
[$sel:fuelUTxO:NodeStarted] :: EndToEndLog -> UTxO
[$sel:otherUTxO:NodeStarted] :: EndToEndLog -> UTxO
PublishedHydraScriptsAt :: TxId -> EndToEndLog
[$sel:hydraScriptsTxId:NodeStarted] :: EndToEndLog -> TxId
UsingHydraScriptsAt :: TxId -> EndToEndLog
[$sel:hydraScriptsTxId:NodeStarted] :: EndToEndLog -> TxId
withHydraCluster :: HasCallStack => Tracer IO EndToEndLog -> FilePath -> FilePath -> Int -> [(VerificationKey PaymentKey, SigningKey PaymentKey)] -> [SigningKey HydraKey] -> TxId -> ContestationPeriod -> (NonEmpty HydraClient -> IO a) -> IO a

-- | Run a hydra-node with given <a>ChainConfig</a> and using the config
--   from config/.
withHydraNode :: Tracer IO EndToEndLog -> ChainConfig -> FilePath -> Int -> SigningKey HydraKey -> [VerificationKey HydraKey] -> [Int] -> TxId -> (HydraClient -> IO a) -> IO a
withConnectionToNode :: Tracer IO EndToEndLog -> Int -> (HydraClient -> IO a) -> IO a

-- | Runs an action with a new connection to given Hydra node.
withNewClient :: HydraClient -> (HydraClient -> IO a) -> IO a
hydraNodeProcess :: RunOptions -> CreateProcess
waitForNodesConnected :: HasCallStack => Tracer IO EndToEndLog -> [HydraClient] -> IO ()
instance Cardano.BM.Data.Tracer.ToObject HydraNode.EndToEndLog
instance Data.Aeson.Types.FromJSON.FromJSON HydraNode.EndToEndLog
instance Data.Aeson.Types.ToJSON.ToJSON HydraNode.EndToEndLog
instance GHC.Generics.Generic HydraNode.EndToEndLog
instance GHC.Show.Show HydraNode.EndToEndLog
instance GHC.Classes.Eq HydraNode.EndToEndLog

module Hydra.Cluster.Scenarios
restartedNodeCanObserveCommitTx :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()
restartedNodeCanAbort :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()

-- | Step through the full life cycle of a Hydra Head with only a single
--   participant. This scenario is also used by the smoke test run via the
--   `hydra-cluster` executable.
singlePartyHeadFullLifeCycle :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()

-- | Ensures the _old_ way of committing (using Fuel) still works.
singlePartyCommitsUsingFuel :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()

-- | Single hydra-node where the commit is done from an external UTxO owned
--   by a script which requires providing script, datum and redeemer
--   instead of signing the transaction.
singlePartyCommitsFromExternalScript :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()
singlePartyCannotCommitExternallyWalletUtxo :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()

-- | Initialize open and close a head on a real network and ensure
--   contestation period longer than the time horizon is possible. For this
--   it is enough that we can close a head and not wait for the deadline.
canCloseWithLongContestationPeriod :: Tracer IO EndToEndLog -> FilePath -> RunningNode -> TxId -> IO ()

-- | Refuel given <a>Actor</a> with given <a>Lovelace</a> if current marked
--   UTxO is below that amount.
refuelIfNeeded :: Tracer IO EndToEndLog -> RunningNode -> Actor -> Lovelace -> IO ()

-- | Return the remaining funds to the faucet
returnFundsToFaucet :: Tracer IO EndToEndLog -> RunningNode -> Actor -> IO ()
headIsInitializingWith :: Set Party -> Value -> Maybe HeadId
